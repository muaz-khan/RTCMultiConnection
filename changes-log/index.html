<!DOCTYPE html>
<html id="home" lang="en">

    <head>
        <title>RTCMultiConnection Changes Log</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <link rel="author" type="text/html" href="https://plus.google.com/+MuazKhan">
        <meta name="author" content="Muaz Khan">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        
        <link rel="stylesheet" href="https://cdn.webrtc-experiment.com/style.css">
	
        <style>
            p { padding: .8em; }

            li {
                border-bottom: 1px solid rgb(189, 189, 189);
                border-left: 1px solid rgb(189, 189, 189);
                padding: .5em;
            }

            .image-container {
                margin: 2em 0;
                text-align: center;
            }

            .image-parent {
                border: 2px solid black;
                border-radius: 5px;
                margin: 0 2em;
            }

            .image-parent img { width: 100%; }

            li p {
                margin-top: 0!important;
                padding-top: 0;
            }
            
            blockquote.inline pre {
                margin: 0;
                background: transparent;
            }
        </style>
        <!-- for HTML5 el styling -->
        <script>
            document.createElement('article');
            document.createElement('footer');
        </script>
	
        <script src="https://cdn.webrtc-experiment.com/syntax/sh_main.min.js" type="text/javascript"> </script>
        <script src="https://cdn.webrtc-experiment.com/syntax/sh_javascript.min.js" type="text/javascript"> </script>
        <script src="https://cdn.webrtc-experiment.com/syntax/sh_html.min.js" type="text/javascript"> </script>
        <link href="https://cdn.webrtc-experiment.com/syntax/sh_style.css" type="text/css" rel="stylesheet">
    </head>

    <body onload="sh_highlightDocument();">
        <article>
            <a href="http://www.RTCMultiConnection.org/" style="border-bottom: 1px solid #2844FA; font-size: 1.2em; position: absolute; right: 0; text-decoration: none; top: 0;">↑ www.RTCMultiConnection.org</a>

            <div class="github-stargazers"></div>
            <h1><a href="http://www.RTCMultiConnection.org/docs/">RTCMultiConnection</a> Changes Log ----/ <a href="http://www.RTCMultiConnection.org/docs/">Docs</a> | <a href="http://www.RTCMultiConnection.org/FAQ/">FAQ</a> | <a href="https://www.webrtc-experiment.com/RTCMultiConnection/">Demos!</a></h1>
		
            <br /><br /><br />
            
            <section class="experiment">
                <h2 id="v2.2"><a href="http://www.rtcmulticonnection.org/changes-log/#v2.2">v2.2</a> / its latest work-in-progress release.</h2>
                
                <blockquote class="inline">
                    <pre class="sh_html">
// install latest package
npm install rtcmulticonnection

// use latest file (v2.*.*)
&lt;script src="./node_modules/rtcmulticonnection/RTCMultiConnection.js"&gt;&lt;/script&gt;

// or instead of installing NPM package,
// directly link the file:
&lt;script src="//cdn.webrtc-experiment.com/RTCMultiConnection.js"&gt;&lt;/script&gt;

// or
&lt;script src="http://www.rtcmulticonnection.org/latest.js"&gt;&lt;/script&gt;

// or
&lt;script src="//cdn.webrtc-experiment.com/RTCMultiConnection-v2.2.5.js"&gt;&lt;/script&gt;
</pre>
                </blockquote>
                
                <ol>
                    <li>
                        NEW/Breaking changes:
                        
                        <ol>
                            <li>
                                RTCMultiSession is renamed to "SignalingHandler"
                            </li>
                            
                            <li>
                                "PeerConnection" is renamed to "RTCPeerConnectionHandler"
                            </li>
                            
                            <li>
                                MultiSockets concept has been removed. Now there is always single socket.
                            </li>
                        </ol>
                    </li>
                    
                    <li>
                        Now, "onSessionClosed" is fired as soon as initiator leaves, for all users---even for NON-connected users.
                    </li>
                    
                    <li>
                        Fixed: onstatechange isn't firing "request-accepted".
                    </li>
                    
                    <li>
                        Fixed: If stream is having no audio or video tracks but session=audio:true,video:true
                    </li>
                    
                    <li>
                        Renegotiation is fixed for Firefox. Removing old stream and using new one.
                    </li>
                    
                    <li>
                        <a href="http://www.rtcmulticonnection.org/docs/takeSnapshot/">takeSnapshot</a> now returns "blob" as second argument.
                    </li>
                    
                    <li>
                        Added: <code>connection.rtcConfiguration</code>:
                        <pre class="sh_html">
connection.rtcConfiguration = {
    iceServers: [],
    iceTransports: 'all'
};
</pre>
                    </li>
                    
                    <li>
                        hark.js updated. <a href="http://www.rtcmulticonnection.org/docs/onspeaking/">onspeaking</a> is disabled for remote streams. Check <a href="https://github.com/muaz-khan/RTCMultiConnection/wiki/Coding-Tricks">Coding Tricks</a> wiki page for further details.
                        <br><br>
                        Now, stream object is having "pause" and "resume" methods to pause/resume hark.js instances.
                    </li>
                    
                    <li>
                        <code>connection.numberOfConnectedUsers</code> is fixed.
                    </li>
                    
                    <li>
                        <code>connection.candidates={relay:true}</code> fixed. (a=candidate is removed).
                    </li>
                    
                    <li>
                        Added: <code>connection.attachExternalStream(MediaStream, isScreen);</code>
                        <pre class="sh_javascript">
navigator.webkitGetUserMedia({
    video: {
        chromeMediaSource: 'screen'
    }
}, function(stream) {
    connection.attachExternalStream(stream, true);
}, function(error) {
    alert(JSON.stringify(error));
};
</pre>
                    </li>
                    
                    <li>
                        Fixed: audio-only stream & crash.
                    </li>
                    
                    <li>
                        <code>connection.stopMediaStream</code> improved.
                    </li>
                    
                    <li>
                        Screen capturing improved & some bugs fixed.
                    </li>
                </ol>
            </section>
            
            <section class="experiment">
                <h2 id="v2.0"><a href="http://www.rtcmulticonnection.org/changes-log/#v2.0">v2.0</a> / released in Sep 01, 2014</h2>
                
                <blockquote class="inline">
                    <pre class="sh_html">
&lt;script src="//cdn.webrtc-experiment.com/RTCMultiConnection-v2.0.js"&gt;&lt;/script&gt;
</pre>
                </blockquote>
                
                <ol>
                    <li>
                        Latest updates: <a href="https://github.com/muaz-khan/RTCMultiConnection/commits/master">https://github.com/muaz-khan/RTCMultiConnection/commits/master</a>
                    </li>
                    
                    <li>
                        v2.2.1 breaking updates:
                        <pre class="sh_javascript">
--. connection.stats.sessions is removed; use connection.sessionDescriptions instead.
--. connection.stats.numberOfSessions is removed; use connection.numberOfSessions instead.
--. connection.stats.numberOfConnectedUsers is removed; use connection.numberOfConnectedUsers instead.
--. connection.getStats and connection.stats are removed.
</pre>
                    </li>
                    
                    <li>
                        Duplicate "enumerateDevices" listing fixed.
                    </li>
                    
                    <li>
                        "connection.DetectRTC.screen.getChromeExtensionStatus" fixed.
                        <pre class="sh_javascript">
document.getElementById('add-screen').onclick = function() {
    connection.DetectRTC.screen.extensionid = 'your-own-extension-id';
    connection.DetectRTC.screen.getChromeExtensionStatus(function(status) {
        if(status == 'installed-enabled') {
            connection.addStream({ screen: true, oneway: true });
        }
    });
};
</pre>
                    </li>
                    
                    <li>
                        Bug-Fixed: Now, MediaStream is removed from "attachStreams" array when stopped.
                    </li>
                    
                    <li>
                        Bug-Fixed: Now, OfferToReceiveAudio/OfferToReceiveVideo are "NOT" forced to be false even for data-only connections. Because it affects renegotiation scenarios.
                    </li>
                    
                    <li>
                        onStreamEndedHandler updated. "connection.onstreamended" is fired only when both "mediaElement" and "mediaElement.parentNode" are not NULL.
                    </li>
                    
                    <li>
                        connection.onopen is now having "event.channel" object.
                    </li>
                    
                    <li>
                        2nd invocation of "createDataChannel" is disabled.
                    </li>
                    
                    <li>
                        Fixed: <a href="https://github.com/muaz-khan/RTCMultiConnection/issues/11">issue#11</a>
                    </li>
                    
                    <li>
                        "connection.enableFileSharing" added.
                        <pre class="sh_javascript">
// to disable file sharing
connection.enableFileSharing = false;
</pre>
                    </li>
                    
                    <li>
                        Added: <code>connection.peers['target-userid'].<a href="http://www.RTCMultiConnection.org/docs/takeSnapshot/"><code>takeSnapshot</code></a>(callback);</code>
                    </li>
                    
                    <li>
                        Added: <code>connection.streams['streamid'].<a href="http://www.RTCMultiConnection.org/docs/takeSnapshot/"><code>takeSnapshot</code></a>(callback);</code>
                    </li>
                    
                    <li>
                        Fixed: "<code><a href="http://www.RTCMultiConnection.org/docs/session/"><code>session</code></a>={data:true}</code>" must not having audio/video media lines.
                    </li>
                    
                    <li>
                        "<a href="http://www.rtcmulticonnection.org/docs/onleave/">onleave</a>" is "merely" fired once for each user.
                    </li>
                    
                    <li>
                        "<code>sync:false</code>" added for "<code>connection.streams['streamid'].mute</code>" method.
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/streams/"><code>streams</code></a>.selectFirst({ local:true }).mute({
    video: true,
    sync: false // mute video locally--only
})

// or
connection.<a href="http://www.RTCMultiConnection.org/docs/streams/"><code>streams</code></a>['streamid'].mute({
    audio: true,
    sync: false // mute audio locally--only
})
</pre>
                    </li>
                    
                    <li>
                        "connection.<a href="http://www.rtcmulticonnection.org/docs/mediaConstraints/">mediaConstraints</a>" updated.
                        <pre class="sh_javascript">
connection.<a href="http://www.rtcmulticonnection.org/docs/mediaConstraints/">mediaConstraints</a> = {
    video: {
        mandatory: {},
        optional: []
    }, 
    audio: {
        mandatory: {},
        optional: []
    }
};
</pre>
                    </li>
                    
                    <li>
                        "<a href="http://www.rtcmulticonnection.org/docs/onstreamended/">onstreamended</a>" fixed. <a href="https://github.com/muaz-khan/RTCMultiConnection/issues/7">Ref</a>
                    </li>
                    
                    <li>
                        Renegotiation fixed. It was a bug in 2.*.* < 2.1.7
                    </li>
                    
                    <li>
                        "<code>connection.rtcConfiguration</code>" added:
                        <pre class="sh_javascript">
connection.rtcConfiguration = {
    iceTransports: 'relay',
    iceServers: [iceServersArray]
}
</pre>
                    </li>
                    
                    <li>
                        <a href="http://www.rtcmulticonnection.org/docs/stopRecording/">stopRecording</a> "callback" fixed.
                        <pre class="sh_javascript">
connection.<a href="http://www.rtcmulticonnection.org/docs/streams/">streams</a>['streamid'].<a href="http://www.rtcmulticonnection.org/docs/stopRecording/">stopRecording</a>(function(blobs) {
    // blobs.video
}, { video: true });
</pre>
                    </li>
                    
                    <li>
                        Now "<a href="http://www.rtcmulticonnection.org/docs/onstreamended/">onstreamended</a>" is fired merely "once" for each stream.
                    </li>
                    
                    <li>
                        <code>{audio:true,video:true}</code> are forced for Android. All media-constraints skipped.
                    </li>
                    
                    <li>
                        Firefox screen capturing is HTTPs-only.
                    </li>
                    
                    <li>
                        Screen negotiations fixed. Screen can be renegotiated many times.
                        <pre class="sh_javascript">
connection.<a href="http://www.rtcmulticonnection.org/docs/addStream/">addStream</a>({
    screen: true,
    oneway: true
});
</pre>
                    </li>
                    
                    <li>
                        "<code>preferJSON</code>" is removed. Now data is "always" sent as ArrayBuffer.
                    </li>
                    
                    <li>
                        "connection.<a href="http://www.rtcmulticonnection.org/docs/candidates/">candidates</a>" has been fixed.
                    </li>
                    
                    <li>
                        Now, <a href="https://github.com/muaz-khan/FileBufferReader">FileBufferReader</a> is used for file sharing.
                    </li>
                    
                    <li>
                        FileSender/FileReceiver/FileConveter has been removed.
                    </li>
                    
                    <li>
                        onFileStart/onFileProgress/onFileEnd: now having "userid" and "extra" objects.
                    </li>
                    
                    <li>
                        When "muted" stream is negotiated; it fires "onmute" event as soon as as remote stream is received.
                        <pre class="sh_javascript">
var firstLocalStream = connection.<a href="http://www.rtcmulticonnection.org/docs/streams/">streams</a>.selectFirst({
    local: true
});

// you can mute a stream before joining a session
firstLocalStream.mute({
    video: true
});

connection.<a href="http://www.rtcmulticonnection.org/docs/open/">open</a>();
</pre>
                    </li>
                    
                    <li>
                        Now, "<code>autoReDialOnFailure</code>" is "true" by default.
                    </li>
                    
                    <li>
                        connection.<a href="http://www.rtcmulticonnection.org/docs/selectDevices/">selectDevices</a> is fixed.
                        <pre class="sh_javascript">
connection.<a href="http://www.rtcmulticonnection.org/docs/selectDevices/">selectDevices</a>('audioinput-deviceid', 'videooutput-deviceid');
</pre>
                    </li>
                    
                    <li>
                        "<code>connection.enumerateDevices</code>" and "<code>connection.getMediaDevices</code>" added.
                        <pre class="sh_javascript">
// to iterate over all available media devices
connection.enumerateDevices(function(devices) {
    devices.forEach(function(device) {
        // device.deviceId
        // device.kind == 'audioinput' || 'audiooutput' || 'audio'
        
        connection.<a href="http://www.RTCMultiConnection.org/docs/selectDevices/"><code>selectDevices</code></a>(device.deviceId);
    });
});
</pre>
                    </li>
                    
                    <li>
                        "connection.changeBandwidth" added.
                        <pre class="sh_javascript">
connection.changeBandwidth({
    audio: 30,
    video: 64
});
</pre>
                    </li>
                    
                    <li>
                        "connection.streams.remove" added.
                        <pre class="sh_javascript">
// fire "onstreamended" for all screen streams
connection.streams.remove({
    isScreen: true
});

// fire "onstreamended" for all local streams
connection.streams.remove({
    local: true
});

// fire "onstreamended" for all remote audio-only streams
connection.streams.remove({
    isAudio: true,
    remote: true
});
</pre>
                    </li>
                    
                    <li>
                        "connection.streams.selectFirst" and "connection.streams.selectAll" added.
                        <pre class="sh_javascript">
// first  local stream
var firstLocalStream = connection.streams.selectFirst({
    local: true
});

// all audio-only streams
var allAudioOnlyStreams = connection.streams.selectAll({
    isAudio: true
});

// a user's all streams
var firstLocalScreenStream = connection.streams.selectAll({
    userid: 'remote-userid'
});
</pre>
                    </li>
                    
                    <li>
                        "connection.streams.stop" improved.
                        <pre class="sh_javascript">
// stop a user's all screen streams
connection.streams.stop({
    userid: 'remote-userid',
    screen: true
});
</pre>
                    </li>
                    
                    <li>
                        "<code>connection.privileges.canStopRemoteStream</code>" and "<code>connection.privileges.canMuteRemoteStream</code>" added:
                        <pre class="sh_javascript">
// set it "true" if you want to allow user to stop/mute remote stream
connection.privileges = {
    canStopRemoteStream: true, // user can stop remote streams
    canMuteRemoteStream: true  // user can mute remote streams
};

// otherwise, for "false" values, if user will try to programmatically invoke "stop" or "mute" method,
// you'll be informed in the "onstatechange" event.
connection.<a href="http://www.RTCMultiConnection.org/docs/onstatechange/"><code>onstatechange</code></a> = function(state) {
    if(state.name == 'stop-request-denied') {
        alert(state.reason);
    }
    
    if(state.name == 'mute-request-denied') {
        alert(state.reason);
    }
};
</pre>
                    </li>
                    
                    <li>
                        Breaking changes for "connection.<a href="http://www.RTCMultiConnection.org/docs/onstatechange/"><code>onstatechange</code></a>". Now an "object" is passed over "<a href="http://www.RTCMultiConnection.org/docs/onstatechange/"><code>onstatechange</code></a>"
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/onstatechange/"><code>onstatechange</code></a> = function(state) {
    // state.userid == 'target-userid' || 'browser'
    // state.extra  == 'target-user-extra-data' || {}
    // state.name  == 'short name'
    // state.reason == 'longer description'
    if(state.name == 'stop-request-denied') {
        alert(state.reason);
    }
};
</pre>
                    </li>
                    
                    <li>
                        "connection.<a href="http://www.RTCMultiConnection.org/docs/streams/"><code>streams</code></a>.mute" updated:
                        <pre class="sh_javascript">
// mute all remote audio-only streams.
connection.<a href="http://www.RTCMultiConnection.org/docs/streams/"><code>streams</code></a>.mute({
    isAudio: true,
    remote: true
});

// unmute all local screen streams.
connection.<a href="http://www.RTCMultiConnection.org/docs/streams/"><code>streams</code></a>.unmute({
    isScreen: true,
    local: true
});
</pre>
                    </li>
                    
                    <li>
                        Fixed <a href="https://github.com/muaz-khan/WebRTC-Experiment/issues/266">#266</a> i.e. IE11 support added through <a href="https://github.com/muaz-khan/PluginRTC">PluginRTC</a> (webrtc-everywhere).
                    </li>
                    
                    <li>
                        <code>connection.UA</code> updated for "<code>is***</code>":
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/UA/"><code>UA</code></a>.isChrome
connection.<a href="http://www.RTCMultiConnection.org/docs/UA/"><code>UA</code></a>.isFirefox
connection.<a href="http://www.RTCMultiConnection.org/docs/UA/"><code>UA</code></a>.isIE
connection.<a href="http://www.RTCMultiConnection.org/docs/UA/"><code>UA</code></a>.isOpera
connection.<a href="http://www.RTCMultiConnection.org/docs/UA/"><code>UA</code></a>.isSafari
connection.<a href="http://www.RTCMultiConnection.org/docs/UA/"><code>UA</code></a>.isMobileDevice
connection.<a href="http://www.RTCMultiConnection.org/docs/UA/"><code>UA</code></a>.version
</pre>
                    </li>
                    
                    <li>
                        <code>connection.preferJSON=true</code> added. You can set "<code>false</code>" to send non-Blob types i.e. <code>ArrayBuffer/ArrayBufferView/DataView</code> etc.
                        <pre class="sh_javascript">
// Remember: it doesn't applies to file sharing.
// it applies to all other kinds of data.
connection.preferJSON = false;

// send array buffer
connection.<a href="http://www.RTCMultiConnection.org/docs/send/"><code>send</code></a>( new ArrayBuffer(10) );

// get array buffer
connection.<a href="http://www.RTCMultiConnection.org/docs/onmessage/"><code>onmessage</code></a> =  function(event) {
    var buffer = event.data;
};

// convert string to array-buffer
connection.<a href="http://www.RTCMultiConnection.org/docs/send/"><code>send</code></a>( str2ab('a string test') );

// parsing array-buffer back into string
connection.<a href="http://www.RTCMultiConnection.org/docs/onmessage/"><code>onmessage</code></a> =  function(event) {
    var string = ab2str(event.data);
};

// this method converts array-buffer into string
function ab2str(buf) {
    return String.fromCharCode.apply(null, new Uint16Array(buf));
}

// this method converts string into array-buffer
function str2ab(str) {
    var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char
    var bufView = new Uint16Array(buf);
    for (var i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}
</pre>
                    </li>
                    
                    <li>
                        <code>connection.sharePartOfScreen</code> fixed for sharing screen over multi-users:
                        <pre class="sh_javascript">
connection.sharePartOfScreen({
    element: 'body', // element to share
    interval: 500    // how after take screenshots
});
</pre>
                    </li>
                    
                    <li>
                        <code>connection.getExternalIceServers</code> is now "<code>false</code>" by default. If you want to use XirSys based ICE-Servers in your application, you MUST set it "<code>true</code>":
                        <pre class="sh_javascript">
// if you want to use XirSys-based STUN/TURN servers
connection.getExternalIceServers = true;
</pre>
                    </li>
                    
                    <li>
                        Now, "<a href="http://www.RTCMultiConnection.org/docs/sendCustomMessage/"><code>sendCustomMessage</code></a>", "<a href="http://www.RTCMultiConnection.org/docs/addStream/"><code>addStream</code></a>", "<code>switchStream</code>", "<a href="http://www.RTCMultiConnection.org/docs/renegotiate/"><code>renegotiate</code></a>" and "<a href="http://www.RTCMultiConnection.org/docs/removeStream/"><code>removeStream</code></a>" can be called even if there is no user connected.
                        <pre class="sh_javascript">
var connection = new RTCMultiConnection();

// quickly after initializing constructor
// call addStream to add screen
// it will wait until a user is connected
// and it will auto share/renegotiate your screen with first user
connection.<a href="http://www.RTCMultiConnection.org/docs/addStream/"><code>addStream</code></a>({
    screen: true,
    oneway: true
});

// send a custom message
// it will be sent as soon as first user connects with you
connection.<a href="http://www.RTCMultiConnection.org/docs/sendCustomMessage/"><code>sendCustomMessage</code></a>('hi, there');
</pre>
                    </li>
                    
                    <li>
                        Added support for initial "inactive" sessions. You can setup audio/video connection however streams will be "inactive":
                        <pre class="sh_javascript">
// streams are on-hold:
connection.<a href="http://www.RTCMultiConnection.org/docs/session/"><code>session</code></a> = {
    inactive: true,
    audio:    true,
    video:    true
};

// to unhold streams later
connection.unhold('both'); // both audio and video
</pre>
                    </li>
                    
                    <li>
                        Added <code>connection.waitUntilRemoteStreamStartsFlowing</code>. It allows you override default Wait-Until-Remote-Stream-starts-flowing behaviour.
                        <pre class="sh_javascript">
connection.waitUntilRemoteStreamStartsFlowing = false;
</pre>
                    </li>
                    
                    <li>
                        Added: <code>connection.switchStream</code>. It will remove all old local streams and add new stream.
                        <pre class="sh_javascript">
// remove all old streams and add screen in oneway.
connection.switchStream({
    screen: true,
    oneway: true
});
</pre>
                    </li>
                    
                    <li>
                        Fixed: TextSender is unable to send array.
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/send/"><code>send</code></a>([1, 2, 3, 4, 5]);
</pre>
                    </li>
                    
                    <li>
                        Added <code>connection.disconnect</code>:
                        <pre class="sh_javascript">
// it means that:
// 1) close all sockets
// 2) close all peers
// 3) clear all data
// 4) refresh everything
// Note: local streams will be kept in "localStreams" object if "keepStreamsOpened" boolean is used.
connection.disconnect();

// it fires: 
connection.ondisconnected = function(event) {
    if(event.isSocketsDisconnected == true) { }
};
</pre>
                    </li>
                    
                    <li>
                        Updated: connection.<a href="http://www.RTCMultiConnection.org/docs/removeStream/"><code>removeStream</code></a>:
                        <pre class="sh_javascript">
// remove all screen streams.
// you can use "remove all video streams" by passing "video"
// or "remove all audio streams" by passing "audio"
connection.<a href="http://www.RTCMultiConnection.org/docs/removeStream/"><code>removeStream</code></a>('screen');

// remove-all but multiple streams
// i.e. remove all audio and video streams
// or remove all audio and screen streams
connection.<a href="http://www.RTCMultiConnection.org/docs/removeStream/"><code>removeStream</code></a>({
    screen: true,
    audio: true
});
</pre>
                    </li>
                    
                    <li>
                        Updated: connection.<a href="http://www.RTCMultiConnection.org/docs/streams/"><code>streams</code></a>.stop:
                        <pre class="sh_javascript">
// stop any single stream: audio or video or screen
connection.<a href="http://www.RTCMultiConnection.org/docs/streams/"><code>streams</code></a>.stop('screen');

// stop multiple streams
connection.<a href="http://www.RTCMultiConnection.org/docs/streams/"><code>streams</code></a>.stop({
    remote: true,
    video: true,
    screen: true
});
</pre>
                    </li>
                    
                    <li>
                        Data-channels "send" method improved.
                        <pre class="sh_javascript">
connection.send('longest-test' || big_array || blob || file);
</pre>
                    </li>
                    
                    <li>
                        Fixed: onStreamEvent.isAudio/onStreamEvent.isVideo seems NULL in mute/unmute cases with only {audio:true} or {video:true}
                        <pre class="sh_javascript">
connection.onmute = function(event) {
    event.isAudio
    event.isVideo
    event.isScreen
};
</pre>
                    </li>
                    
                    <li>
                        <code>googTemporalLayeredScreencast</code> and <code>googLeakyBucket</code> added for screen capturing.
                    </li>
                    
                    <li>
                        Updated <code>connection.candidates</code>:
                        <pre class="sh_javascript">
connection.candidates = {
    stun: true, // NEW property since v2.0
    turn: true, // NEW property since v2.0
    host: true
};
</pre>
                    </li>
                    
                    <li>
                        Added <code>connection.localStreams</code>. All local streams are always kept in this object even if session is closed. Look at above section i.e. <code>keepStreamsOpened</code>.
                        <pre class="sh_javascript">
var stream = connection.localStreams['streamid'];

// or
connection.onSessionClosed = function() {
    var stream = connection.localStreams['streamid'];
};

// or
for(var streamid in connection.localStreams) {
    var stream = connection.localStreams[streamid];
}
</pre>
                    </li>
                    
                    <li>
                        Added <code>connection.log</code> and <code>connection.onlog</code>. It allows you display logs in UI instead of in the console.
                        <pre class="sh_javascript">
// if you want to disable logs
connection.log = false;

connection.onlog = function(log) {
    var div = document.createElement('div');
    div.innerHTML = JSON.stringify(log, null, '&lt;br&gt;');
    document.documentElement.appendChild(div);
};
</pre>
                    </li>
                    
                    <li>
                        Added <code>connection.keepStreamsOpened</code>. It allows you keep MediaStream active even if entire session is closed. It is useful in session-reinitiation scenarios.
                        <pre class="sh_javascript">
connection.keepStreamsOpened = true;
</pre>
                    </li>
                    
                    <li>
                        Removed: <code>connection.caniuse.checkIfScreenSharingFlagEnabled</code>. It was redundant.
                    </li>
                    
                    <li>webrtc-everywhere/temasys support added for Safari & IE11. <a href="https://github.com/muaz-khan/PluginRTC">PluginRTC</a></li>
                </ol>
                
            </section>
            <section class="experiment">
                <h2 id="v1.9"><a href="http://www.rtcmulticonnection.org/changes-log/#v1.9">v1.9</a> / released in August 10, 2014</h2>
                
                <blockquote class="inline">
                    <pre class="sh_html">
&lt;script src="//cdn.webrtc-experiment.com/RTCMultiConnection.js"&gt;&lt;/script&gt;

// or
&lt;script src="//cdn.webrtc-experiment.com/RTCMultiConnection-v1.9.js"&gt;&lt;/script&gt;

// or
&lt;script src="//www.rtcmulticonnection.org/latest.js"&gt;&lt;/script&gt;
</pre>
                </blockquote>
                
                <ol>
                    <li>
                        Workaround-added: <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1045810">Firefox don't yet support onended for any stream</a> (remote/local)
                    </li>
                    <li>
                        RTCMultiConnection is updated for <code>audio+screen</code> from single getUserMedia request for Firefox Nightly. Below snippet is sharing single video stream containing both audio/video tracks; and target browser is joining with only audio. Screen can be viewed on both chrome and Firefox. If you'll share from chrome, then it will be making multiple getUserMedia requests.
                        <pre class="sh_javascript">
// audio+video+screen will become audio+screen for Firefox
// because Firefox isn't supporting multi-streams feature

// initiator from Firefox
initiator.<a href="http://www.RTCMultiConnection.org/docs/session/"><code>session</code></a> = {
    screen: true,
    audio: true
};

// participant in chrome or Firefox
participant.<a href="http://www.RTCMultiConnection.org/docs/onNewSession/"><code>onNewSession</code></a> = function(session) {
    session.join({ audio: true });
};
</pre>
                    </li>
                    <li>
                        Screen capturing support for Firefox nightly added. You simply need to open "<code>about:config</code>" on Firefox nightly and set "<code>media.getusermedia.screensharing.enabled</code>" to "<code>true</code>".
                        <pre class="sh_javascript">
// same for Firefox
connection.<a href="http://www.RTCMultiConnection.org/docs/session/"><code>session</code></a> = {
    screen: true,
    oneway: true
};
</pre>
                    </li>
                    
                    <li>
                        <code>connection.<a href="http://www.RTCMultiConnection.org/docs/dontCaptureUserMedia/"><code>dontCaptureUserMedia</code></a></code> added:
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/dontCaptureUserMedia/"><code>dontCaptureUserMedia</code></a> = true;
</pre>
                    </li>
                    
                    <li>
                        <code>connection.<a href="http://www.RTCMultiConnection.org/docs/dontAttachStream/"><code>dontAttachStream</code></a></code> updated:
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/dontAttachStream/"><code>dontAttachStream</code></a> = true;
</pre>
                    </li>
                    
                    <li>
                        <code>connection.onstreamid</code> added:
                        <pre class="sh_javascript">
// on getting remote stream's clue
connection.<a href="http://www.RTCMultiConnection.org/docs/onstreamid/"><code>onstreamid</code></a> = function (e) {
    var mediaElement = document.createElement(e.isAudio ? 'audio' : 'video');
    mediaElement.controls = true;
    mediaElement.poster = connection.resources.muted;
    mediaElement.id = e.streamid;
    connection.body.appendChild(mediaElement);
};
</pre>
                    </li>
                    
                    <li>
                        <code>connection.peers['target-userid'].getStats</code> added.
                        <pre class="sh_javascript">
connection.peers['target-userid'].peer.getStats(function (result) {
    // many useful statistics here
});
</pre>
                    </li>
                    
                    <li>
                        <code>connection.onconnected</code> added.
                        <pre class="sh_javascript">
connection.onconnected = function (event) {
    log('Peer connection has been established between you and', event.userid);
    
    // event.peer.addStream || event.peer.removeStream || event.peer.changeBandwidth
    // event.peer == connection.peers[event.userid]
    
    event.peer.getStats(function (result) {
        // many useful statistics here
    });
};
</pre>
                    </li>
                    
                    <li>
                        <code>connection.onfailed</code> added.
                        <pre class="sh_javascript">
connection.onfailed = function (event) {
    event.peer.renegotiate();
    // or event.peer.redial();
    // event.targetuser.browser == 'firefox' || 'chrome'
};
</pre>
                    </li>
                    
                    <li>
                        <code>connection.<a href="http://www.RTCMultiConnection.org/docs/eject/"><code>eject</code></a></code> is fixed.
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/eject/"><code>eject</code></a>('target-userid');

// check if user is ejected
// clear rooms-list if user is ejected
connection.<a href="http://www.RTCMultiConnection.org/docs/onSessionClosed/"><code>onSessionClosed</code></a> = function (session) {
    if (session.isEjected) {
        warn(session.userid, 'ejected you.');
    } else warn('Session has been closed.', session);

    if (session.isEjected) {
        roomsList.innerHTML = '';
        roomsList.style.display = 'block';
    }
};
</pre>
                    </li>
                    
                    <li>
                        Fixed: <code>remoteEvent.streamid</code> and <code>remoteEvent.isScreen</code>:
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/onstream/"><code>onstream</code></a> = function(event) {
    if(event.isScreen) {
        // it is screen
    }
};
</pre>
                    </li>
                    
                    <li>
                        Screen capturing is improved, and <a href="https://chrome.google.com/webstore/detail/screen-capturing/ajhifddimkapgcifgcodmmfdlknahffk">single google chrome extension</a> is used to support capturing from all domains!
                    </li>
                    
                    <li>
                        <code>connection.<a href="http://www.RTCMultiConnection.org/docs/processSdp/"><code>processSdp</code></a></code> added.
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/processSdp/"><code>processSdp</code></a> = function(sdp) {
    sdp = remove_vp8_codecs(sdp);
    sdp = prefer_opus (sdp);
    sdp = use_maxaveragebitrate(sdp);
    return sdp;
};
</pre>
                    </li>
                    
                    <li>
                        <code><a href="http://www.RTCMultiConnection.org/docs/session/">connection.session</a>={}</code> fixed. It allows moderator/initiator to become a listener/viewer i.e. it supports many-to-one scenarios:
                        <pre class="sh_javascript">
// for initiator
connection.<a href="http://www.RTCMultiConnection.org/docs/session/"><code>session</code></a> = {};

// for participants
connection.<a href="http://www.RTCMultiConnection.org/docs/onNewSession/"><code>onNewSession</code></a> = function(session) {
    session.<a href="http://www.RTCMultiConnection.org/docs/join/"><code>join</code></a>({
        audio: true,
        video: true
    });
};
</pre>
                    </li>
                    
                    <li>
                        <code><a href="http://www.RTCMultiConnection.org/docs/mediaConstraints/">connection.mediaConstraints</a></code> and <code><a href="http://www.RTCMultiConnection.org/docs/media/">connection.media</a></code> are updated:
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/mediaConstraints/"><code>mediaConstraints</code></a> = {
    mandatory: {
        maxWidth: 1920,
        maxHeight: 1080,
        minAspectRatio: 1.77,

        minFrameRate: 3,
        maxFrameRate: 64
    },
    optional: [
        bandwidth: 256
    ]
};
</pre>
                    </li>
                    
                    <li>
                        <code><a href="http://www.RTCMultiConnection.org/docs/onstream/">connection.onstream</a></code> is updated for <code>event.isScreen</code>:
                        <pre class="sh_javascript">
connection.<code><a href="http://www.RTCMultiConnection.org/docs/onstream/">onstream</a></code> = function (event) {
    if(event.isScreen) {
        // it is screen stream
    }
    
    if(event.isAudio) {
        // it is audio-only stream
    }
    
    if(event.isVideo) {
        // it is audio+video stream
    }
};
</pre>
                    </li>
                    
                    <li>
                        <code><a href="http://www.RTCMultiConnection.org/docs/refresh/">connection.refresh</a></code> is updated and session re-initiation is improved.
                        <pre class="sh_javascript">
// you simply need to invoke "connection.<code><a href="http://www.RTCMultiConnection.org/docs/leave/">leave</a></code>" to 
// leave a session so that you can rejoin same session
connection.<code><a href="http://www.RTCMultiConnection.org/docs/onstatechange/">onstatechange</a></code> = function (state) {
    if(state == 'connected-with-initiator') {
        document.getElementById('leave-session').disabled = false;
    }
};

document.getElementById('leave-session').onclick = function() {
    connection.<code><a href="http://www.RTCMultiConnection.org/docs/leave/">leave</a></code>();
};
</pre>
                    </li>
                    
                    <li>
                        <code>connection.iceProtocols</code> added.
                        <pre class="sh_javascript">
connection.iceProtocols = {
    tcp: true, // prefer using TCP-candidates
    udp: true  // prefer using UDP-candidates
};
</pre>
                    </li>
                    
                    <li>
                        Use custom chrome extension for screen capturing:
                        <pre class="sh_javascript">
connection.<code><a href="http://www.rtcmulticonnection.org/docs/DetectRTC/">DetectRTC</a></code>.screen.<code><a href="http://www.rtcmulticonnection.org/docs/DetectRTC/#DetectRTC.screen">extensionid</a></code> = 'your-app-store-extensionid';
</pre>
                    </li>
                    
                    <li>
                        STUN/TURN servers are updated; as well as ICE-servers from XirSys are used:
                        <pre class="sh_javascript">
// to disable XirSys ICE-Servers
connection.getExternalIceServers = false;
</pre>
                    </li>
                    
                    <li>
                        <code>connection.preventSSLAutoAllowed</code> is disabled.
                        <pre class="sh_javascript">
// to enable it
connection.preventSSLAutoAllowed = true;
</pre>
                    </li>
                </ol>
                
            </section>
            
            <section class="experiment">
                <h2 id="v1.8"><a href="http://www.rtcmulticonnection.org/changes-log/#v1.8">v1.8</a> / released in June 28, 2014</h2>
                
                <blockquote class="inline">
                    <pre class="sh_html">
&lt;script src="//cdn.webrtc-experiment.com/RTCMultiConnection-v1.8.js"&gt;&lt;/script&gt;
</pre>
                </blockquote>
                
                <ol>
                    <li>
                        (to fix canary ipv6 candidates issues): disabled "googIPv6", "googDscp" and "googImprovedWifiBwe"
                    </li>
                    
                    <li>
                        "<code>connection.leaveOnPageUnload</code>" added.
                        <pre class="sh_javascript">
// if you want to prevent/override/bypass default behaviour
connection.<a href="http://www.RTCMultiConnection.org/docs/leaveOnPageUnload/"><code>leaveOnPageUnload</code></a> = false;

// display a notification box
window.addEventListener('beforeunload', function () {
    return 'Are you want to leave?';
}, false);

// leave here
window.addEventListener('unload', function () {
    connection.<a href="http://www.RTCMultiConnection.org/docs/leave/">leave</a>();
}, false);
</pre>
                    </li>
                    
                    <li>
                        <pre class="sh_javascript">
-. renegotiation scenarios that fails:
-. 1) if chrome starts video-only session and firefox joins with only audio
-. 2) if chrome starts with audio-only session and firefox joins with only video
-. 3) if chrome starts only audio and firefox joins with audio+video
-. renegotiation scenarios that works:
-. 1) if chrome starts audio+video and firefox joins with only audio or audio+video
-. 2) if both browsers has similar streams
</pre>
                    </li>
                    
                    <li>
                        "connection.<a href="http://www.RTCMultiConnection.org/docs/onstatechange/"><code>onstatechange</code></a>" added:
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/onstatechange/"><code>onstatechange</code></a> = function (state, reason) {
    // fetching-usermedia
    // usermedia-fetched

    // detecting-room-presence
    // room-not-available
    // room-available

    // connecting-with-initiator
    // connected-with-initiator

    // failed---has reason

    // request-accepted
    // request-rejected

    if(state == 'room-not-available') {
        // room no longer exist
    }
};
</pre>
                        Remember, older "<code><a href="http://www.rtcmulticonnection.org/docs/onstats/">onstats</a></code>" event has been removed in v1.8.
                    </li>
                    
                    <li>
                        Now if you'll invoke "<code>connection.<a href="http://www.RTCMultiConnection.org/docs/sharePartOfScreen/"><code>sharePartOfScreen</code></a>(...)</code>" and a new user will join you; existing part of screen will be auto shared with him.<br /><br />
                        It means that "<code><a href="http://www.RTCMultiConnection.org/docs/sharePartOfScreen/"><code>sharePartOfScreen</code></a></code>" will work with all new/old users.
                    </li>
                    
                    <li>
                        "<code>connection.donotJoin</code>" added:
                        <pre class="sh_javascript">
connection.onstatechange = function (state) {
    if(state == 'room-not-available') {
        connection.donotJoin(connection.sessionid);
    }
};
</pre>
                    </li>
                    
                    <li>
                        You can set <code>connection.DetectRTC.screen.extensionid="your-chrome-extensionid"</code> to make sure inline (newly) installed chrome extension is quickly used for screen capturing instead of prompting user to reload page once to use it.<br /><br />
                        It means that install the chrome extension and RTCMultiConnection will auto use it. Don't ask your users to reload the page:
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/DetectRTC/"><code>DetectRTC</code></a>.screen.extensionid = 'ajhifddimkapgcifgcodmmfdlknahffk';
</pre>
                    </li>
                    
                    <li>
                        Fixed: If Chrome starts video-only session; and Firefox joins with only audio. Then both fails to connect; though sendrecv/recvonly/sendonly everything is correctly implemented.
                    </li>
                    
                    <li>
                        Fixed: "the videos are not square and they look grainy not has sharp as before". Now video is captured & streamed with better quality.
                    </li>
                    
                    <li>
                        "<code>connection.<a href="http://www.RTCMultiConnection.org/docs/DetectRTC/"><code>DetectRTC</code></a>.hasSpeakers</code>" added.
                    </li>
                    
                    <li>
                        "<code>connection.<a href="http://www.RTCMultiConnection.org/docs/resumePartOfScreenSharing/"><code>resumePartOfScreenSharing</code></a>()</code>" added.
                    </li>
                    
                    <li>
                        "<code>event.blobURL</code>" in the <code><a href="http://www.rtcmulticonnection.org/docs/onstream/">onstream</a></code> event is fixed for Firefox.
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/onstream/"><code>onstream</code></a> = function(e) {
    // e.blobURL -- now it is always blob:URI
};
</pre>
                    </li>
                    
                    <li>
                        <a href="http://www.RTCMultiConnection.org/docs/startRecording/">startRecording</a>/<a href="http://www.RTCMultiConnection.org/docs/stopRecording/">stopRecording</a> updated & fixed.
                        <pre class="sh_javascript">
// record both audio and video
connection.<a href="http://www.RTCMultiConnection.org/docs/streams/">streams</a>['stream-id'].<a href="http://www.RTCMultiConnection.org/docs/startRecording/">startRecording</a>({
    audio: true,
    video: true
});

// stop both audio and video
connection.<a href="http://www.RTCMultiConnection.org/docs/streams/">streams</a>['stream-id'].<a href="http://www.RTCMultiConnection.org/docs/stopRecording/">stopRecording</a>(function (blob) {
    // blob.audio  --- audio blob
    // blob.video  --- video blob
}, {audio:true, video:true} );
</pre>
                    </li>
                
                    <li>
                        "PreRecordedMediaStreamer" is moved to a separate javascript file.
                        <pre class="sh_javascript">
https://www.rtcmulticonnection.org/PreRecordedMediaStreamer.js
</pre>
                    </li>
                    
                    <li>
                        function "<code>stopTracks</code>" updated.
                    </li>
                
                    <li>
                        Fixed <code>connection.streams.stop()</code> via <a href="https://github.com/muaz-khan/WebRTC-Experiment/issues/225#issuecomment-46283072">issue #255</a>.
                    </li>
                
                    <li>
                        Now, you can easily manage external resources/URLs using "<code>connection.resources</code>":
                        <pre class="sh_javascript">
connection.resources = {
    RecordRTC: 'https://www.webrtc-experiment.com/RecordRTC.js',
    PreRecordedMediaStreamer: 'https://www.rtcmulticonnection.org/PreRecordedMediaStreamer.js',
    customGetUserMediaBar: 'https://www.webrtc-experiment.com/navigator.customGetUserMediaBar.js',
    html2canvas: 'https://www.webrtc-experiment.com/screenshot.js',
    hark: 'https://www.rtcmulticonnection.org/hark.js',
    firebase: 'https://www.rtcmulticonnection.org/firebase.js',
    firebaseio: 'https://chat.firebaseIO.com/',
    muted: 'https://www.webrtc-experiment.com/images/muted.png'
};
</pre>
                    </li>
                
                    <li>
                        <code>connection.<a href="http://www.RTCMultiConnection.org/docs/DetectRTC/"><code>DetectRTC</code></a>.MediaDevices</code> added:
                        <pre class="sh_javascript">
// to iterate over all available media devices
connection.<a href="http://www.RTCMultiConnection.org/docs/getDevices/"><code>getDevices</code></a>(function() {
    connection.<a href="http://www.RTCMultiConnection.org/docs/DetectRTC/"><code>DetectRTC</code></a>.MediaDevices.forEach(function(device) {
        // device.deviceId
        // device.kind == 'audioinput' || 'audiooutput' || 'audio'
        
        connection.<a href="http://www.RTCMultiConnection.org/docs/selectDevices/"><code>selectDevices</code></a>(device.deviceId);
    });
});
</pre>
                    </li>
                
                    <li>
                        Now, <code>hark.js</code> is used instead of <code>SoundMeter.js</code>:
                        <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/onspeaking/">onspeaking</a> = function() {};
connection.<a href="http://www.RTCMultiConnection.org/docs/onsilence/">onsilence</a> = function() {};
</pre>
                    </li>
                
                    <li>
                        <code>captureUserMediaOnDemand</code> added for <code>connection.open</code> method:
                        <pre class="sh_javascript">
// it is "disabled" by default
// captureUserMediaOnDemand means that "getUserMedia" API for initiator will 
// be invoked only when required.
// i.e. when first participant is detected.

// you can enable it by setting it to "true"
connection.open({
    captureUserMediaOnDemand: true
});
</pre>
                    </li>
                
                    <li>
                        <code>connection.DetectRTC.screen.getChromeExtensionStatus</code> added.
                        <pre class="sh_javascript">
var extensionid = 'ajhifddimkapgcifgcodmmfdlknahffk';

connection.<a href="http://www.RTCMultiConnection.org/docs/DetectRTC/"><code>DetectRTC</code></a>.screen.getChromeExtensionStatus(extensionid, function(status) {
    if(status == 'installed-enabled') {
        // chrome extension is installed & enabled.
    }
    
    if(status == 'installed-disabled') {
        // chrome extension is installed but disabled.
    }
    
    if(status == 'not-installed') {
        // chrome extension is not installed
    }
    
    if(status == 'not-chrome') {
        // using non-chrome browser
    }
});
</pre>
                    </li>
                    
                    <li>
                        <code>onMediaCaptured</code> added for <code>connection.open</code> method:
                        <pre class="sh_javascript">
connection.open({
    onMediaCaptured: function() {
        // initiator enable camera/microphone
        // you can share "sessionDescription" with other users
        // and they can quickly join initiator!
    }
});
</pre>
                    </li>
                    
                    <li>
                        <code>openSignalingChannel</code> is moved to "<code>setDefaults</code>" private function.
                    </li>
                
                    <li>
                        <code>connection.preventSSLAutoAllowed</code> added. Now RTCMultiConnection focuses more on end-users privacy! You can ask RTCMultiConnection to "always" display "getUserMedia-permission-bar" even if chrome is running on HTTPs i.e. SSL domain:
                        <pre class="sh_javascript">
// by default "preventSSLAutoAllowed" is true only for "HTTPs" domains
// you can force it for HTTP domains as well by setting this Boolean in your HTML page.
connection.preventSSLAutoAllowed = true;
</pre>
                    </li>
                    
                    <li>
                        <code>onScreenCapturingExtensionAvailable</code>  is fired when RTCMultiConnection detects that chrome extension for screen capturing is installed and available:
                        <pre class="sh_javascript">
connection.onScreenCapturingExtensionAvailable = function() {
    btnInlineInstallButton.disabled = true;
};
</pre>
                    </li>
                    
                    <li>
                        Now, <code>connection.<a href="http://www.RTCMultiConnection.org/docs/join/">join</a></code> method allows you force how to join (i.e. with or without streams etc.):
                        <pre class="sh_javascript">
// it doesn't matter if incoming stream is audio+video
// you can join it with only audio or with only video
// or anonymously i.e. { oneway: true }
var joinWith = {
    audio: true
};

connection.<a href="http://www.RTCMultiConnection.org/docs/join/">join</a>('sessionid', joinWith); // 2nd parameter
</pre>
                    </li>
                    
                    <li>
                        Now, <a href="http://www.RTCMultiConnection.org/docs/onNewSession/">onNewSession</a> is fired once for each room. It will NEVER fire multiple times.
                    </li>
                    
                    <li>
                        <code><a href="https://github.com/muaz-khan/WebRTC-Experiment/tree/master/desktop-sharing">chrome.desktopCapture.chooseDesktopMedia</a></code> is now preferred for screen capturing; and if extension is not installed or disabled, then RTCMultiConnection will auto fallback to <a href="https://www.webrtc-experiment.com/Pluginfree-Screen-Sharing/">command-line flag oriented screen-capturing API</a>; and if both are not available then it will throw a clear "human readable" exception.<br /><br />
                        Chrome extension is available <a href="https://www.webrtc-experiment.com/store/capture-screen/">here</a>.
                    </li>
                    
                    <li>
                        You can use <code>connection.DetectRTC</code> like this:
                        <pre class="sh_javascript">
connection.DetectRTC.load(function() {
    if(connection.DetectRTC.hasMicrophone) { }
    if(connection.DetectRTC.hasWebcam) { }
});

connection.DetectRTC.screen.isChromeExtensionAvailable(function(available) {
    if(available) alert('Chrome screen capturing extension is installed and available.');
}):
</pre>
                    </li>
                    
                    <li>
                        <code>navigator.getUserMedia</code> errors handling in <code>onMediaError</code> event:
                        <pre class="sh_javascript">
connection.onMediaError = function(error) {
    if(error.name == 'PermissionDeniedError') {
        alert(error.message);
    }
};
</pre>
                    </li>
                </ol>
            </section>
            
            <section class="experiment">
            
            <h2 id="v1.7"><a href="http://www.rtcmulticonnection.org/changes-log/#v1.7">v1.7</a> / released in May 14, 2014</h2>
		
                <blockquote class="inline">
                    v1.7 focused on reliable API invocation, reliable concurrent users connectivity, and more. A few other features were added in this build like part of screen streaming, pre-recorded media streaming, ice-trickling booleans, and obviously DetectRTC!
                    
                    <pre class="sh_html">
&lt;script src="//cdn.webrtc-experiment.com/RTCMultiConnection-v1.7.js"&gt;&lt;/script&gt;
</pre>
                </blockquote>
                
            <ol>
                <li>
                    <code>connection.trickleIce</code> added. Useful if you're using XHR/SIP/XMPP for signaling. <a href="https://github.com/muaz-khan/XHR-Signaling">XHR Demo</a>
                    <pre class="sh_javascript">
// to ask RTCMultiConnection to wait until all ICE candidates
// are gathered; and all ice are merged in the SDP
// you JUST need to share that SDP "only"!
connection.trickleIce = false;
</pre>
                </li>
                
                <li>
                    You can use "<code>connection.DetectRTC</code>" to <a href="https://github.com/muaz-khan/WebRTC-Experiment/blob/master/DetectRTC">detect</a> WebRTC features!
                    <pre class="sh_javascript">
if(connection.DetectRTC.isWebRTCSupported) {}
if(connection.DetectRTC.hasMicrophone) {}
if(connection.DetectRTC.hasWebcam) {}
</pre>
                </li>
                
                <li>
                    Following scenarios implemented:
                    <ol>
                        <li>if system doesn't have any microphone attached; RTCMultiConnection will skip "<code>{audio:true}</code>" and prompt only "<code>{video: true}</code>"</li>
                        <li>if system doesn't have any webcam attached; RTCMultiConnection will skip "<code>{video:true}</code>" and prompt only "<code>{audio: true}</code>"</li>
                    </ol>
                </li>
                
                <li>
                    Previously "<code>connection.renegotiatedSessions</code>" was an array; now it is object.
                    <pre class="sh_javascript">
// sometimes you try to manually fetch media streams
// sometimes you allow a user to enable webcam ... but don't renegotiate quickly..
// you may want to ask other user to invoke "renegotiate" function
// you may want to override default behaviours

// below code snippet is used in MultiRTC demo in "ui-peer-connection.js" file

var session = {
    audio: true // you're manually capturing audio
};

connection.captureUserMedia(function (stream) {
    // you can see that "renegotiatedSessions" is an object
    // because we wanted to prevent duplicate entries
    connection.renegotiatedSessions[ JSON.stringify(session) ] = {
        session: session,
        stream: stream
    }

    connection.peers[message.userid].peer.connection.addStream(stream);
}, session);
</pre>
                </li>
                
                <li>
                    Now, using default camera resolutions instead of using minWidth/minHeight and maxWidth/maxHeight. You can <a href="http://www.RTCMultiConnection.org/docs/mediaConstraints/">easily override</a> those values:
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/mediaConstraints/">mediaConstraints</a>.mandatory = {
    minWidth: 1280,
    maxWidth: 1280,
    minHeight: 720,
    maxHeight: 720,
    minAspectRatio: 1.77
};
</pre>
                </li>
                
                <li>
                    Now, auto redials while you're renegotiating and any single browser is firefox!
                </li>
                
                <li>
                    Previously-renegotiated streams and new users renegotiation has been improved.
                </li>
                
                <li>
                    Now, auto injecting <code>VoiceActivityDetection:true</code> for chrome to make sure <code>c=IN</code> is always present; otherwise <code>b=AS</code> will fail.
                </li>
                
                <li>
                    <code>connection.dontOverrideSession</code> added:
                    <pre class="sh_javascript">
// dont-override-session allows you force RTCMultiConnection
// to not override default session of participants;
// by default, session is always overridden and set to the session coming from initiator!
connection.dontOverrideSession = true;
</pre>
                </li>
                
                <li>
                    <code>connection.askToShareParticipants</code> and <code>connection.shareParticipants</code> added. Useful in <a href="https://www.webrtc-experiment.com/RTCMultiConnection/Multi-Broadcasters-and-Many-Viewers.html">multi-broadcasters and many viewers scenarios</a>!
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/onstream/">onstream</a> = function (e) {
    if (e.type == 'remote' && role == 'Anonymous Viewer') {
        // because "viewer" joined room as "oneway:true"
        // initiator will NEVER share participants
        // to manually ask for participants;
        // call "askToShareParticipants" method.
        connection.askToShareParticipants();
    }

    // if you're moderator
    // if stream-type is 'remote'
    // if target user is broadcaster!
    if (connection.isInitiator && e.type == 'remote' && !e.session.oneway) {
        // call "shareParticipants" to manually share participants with all connected users!
        connection.shareParticipants({
            dontShareWith: e.userid
        });
    }
};
</pre>
                </li>
                
                <li>
                    <code>connection.<a href="http://www.RTCMultiConnection.org/docs/join/">join</a>('sessionid')</code> has been improved.
                </li>
                
                <li>
                    Now you can pass "sessionid" over "join" method!
                    <pre class="sh_javascript">
// make sure that room is created!
// otherwise this "join" method will fail to join the room!
// "join" method NEVER waits for onNewSession!!
// it directly "joins" the room!
connection.<a href="http://www.RTCMultiConnection.org/docs/join/">join</a>('sessionid');
</pre>
                </li>
                
                <li>
                    Session re-initiation has been fixed. You can leave/rejoin many times.
                </li>
                
                <li>
                    <a href="http://www.rtcmulticonnection.org/docs/admin-guest/">Admin/Guest features</a> has been removed. You should use v1.6 or earlier to use admin/guest features.
                </li>
                <li>
                    <code>screen:300kbps</code> added in <code>connection.<a href="http://www.RTCMultiConnection.org/docs/bandwidth/">bandwidth</a></code>:
                    <pre class="sh_javascript">
// by default
connection.<a href="http://www.RTCMultiConnection.org/docs/bandwidth/">bandwidth</a> = {
    screen: 300
};

// if you're using node-webkit; then you MUST set it to NULL
// make sure that it is set both for browser-client and node-webkit!
connection.<a href="http://www.RTCMultiConnection.org/docs/bandwidth/">bandwidth</a>.screen = null;
</pre>
                </li>
                <li>
                    Now, you can check <code>connection.<a href="http://www.RTCMultiConnection.org/docs/stats/">stats</a>.numberOfSessions</code> in a specific channel:
                    <pre class="sh_javascript">
alert( connection.<a href="http://www.RTCMultiConnection.org/docs/stats/">stats</a>.numberOfSessions );

// You can even access all sessions using this object-like array:
alert( connection.<a href="http://www.RTCMultiConnection.org/docs/stats/">stats</a>.sessions['sessionid'] );

// or
for(var session in connection.<a href="http://www.RTCMultiConnection.org/docs/stats/">stats</a>.sessions) {
    console.log(connection.<a href="http://www.RTCMultiConnection.org/docs/stats/">stats</a>.sessions[session]);
}

// You can get above values usnig "getStats" method as well:
connection.<a href="http://www.RTCMultiConnection.org/docs/getStats/">getStats</a>(function(stat) {
    console.log(stat.numberOfSessions);
    
    for(var session in stat.sessions) {
       console.log(stat.sessions[session]);
    }
});
</pre>
                </li>
                
                <li>
                    Now, multiple users can join a room at the same time and all will be interconnected!
                </li>
                
                <li>
                    Now, "streamid" is synced among all users! You can mute/unmute or stop single stream-id and it will affect among all connected users!
                </li>
                
                <li>
                    <code>autoReDialOnFailure</code> added. You can force RTCMultiConnection to auto redial if peer connection is dropped unexpectedly or failed out of any exception!
                    <pre class="sh_javascript">
// by default, it is "false"
// it is false because workaround that is used to capture connections' failures
// affects renegotiation scenarios!
connection.autoReDialOnFailure = true;
</pre>
                </li>
                
                <li>
                    You can override <a href="http://www.RTCMultiConnection.org/docs/setDefaultEventsForMediaElement/"><code>setDefaultEventsForMediaElement</code></a> to prevent default mute/unmute handlers on media elements.
                    <pre class="sh_javascript">
// by default it captures "onplay", "onpause" and "onvolumechange" events for all media elements
connection.<a href="http://www.RTCMultiConnection.org/docs/setDefaultEventsForMediaElement/"><code>setDefaultEventsForMediaElement</code></a> = false;
</pre>
                </li>
                
                <li>
                    <code>onpartofscreenstopped</code> and <code>onpartofscreenpaused</code> added:
                    <pre class="sh_javascript">
// invoked when you "manually" stopped part-of-screen sharing!
connection.onpartofscreenstopped = function() {};

// invoked when you "manually" paused part-of-screen sharing!
connection.onpartofscreenpaused = function() {};
</pre>
                </li>
                
                <li>
                    Now, you can call <code>sharePartOfScreen</code>, <code>pausePartOfScreenSharing</code> and <code>stopPartOfScreenSharing</code> for all users:
                    <pre class="sh_javascript">
connection.sharePartOfScreen({
    element: '#div-id', // querySelector or HTMLElement
    interval: 1000      // milliseconds
});

connection.<a href="http://www.RTCMultiConnection.org/docs/pausePartOfScreenSharing/"><code>pausePartOfScreenSharing</code></a>();
connection.<a href="http://www.RTCMultiConnection.org/docs/stopPartOfScreenSharing/"><code>stopPartOfScreenSharing</code></a>();
</pre>
                </li>
                
                <li>
                    <code>hold/unhold</code> of individual media lines implemented:
                    <pre class="sh_javascript">
// hold only your audio
connection.<a href="http://www.rtcmulticonnection.org/docs/peers/">peers</a>['target-userid'].hold('audio');
connection.<a href="http://www.rtcmulticonnection.org/docs/onhold/">onhold</a> = function(track) {
    if(track.kind == 'audio') {}
};

// hold only your video
connection.<a href="http://www.rtcmulticonnection.org/docs/peers/">peers</a>['target-userid'].hold('video');
connection.<a href="http://www.rtcmulticonnection.org/docs/onunhold/">onunhold</a> = function(track) {
    if(track.kind == 'video') {}
};

// unhold all your 'video' m-lines
connection.unhold('video');

// hold all your 'audio' m-lines
connection.hold('audio');
</pre>
                </li>
                
                <li>
                    When you mute/unmute; video-controls are synced among all users! Volume is also synced!
                </li>
                
                <li>
                    <code>window.skipRTCMultiConnectionLogs</code> is replaced with <code>connection.skipLogs</code> method:
                    <pre class="sh_javascript">
connection.skipLogs();
</pre>
                </li>
                
                <li>
                    Part of screen sharing has been implemented:
                    <pre class="sh_javascript">
// to share a DIV or region of screen with a specific user
connection.<a href="http://www.rtcmulticonnection.org/docs/peers/">peers</a>['target-userid'].sharePartOfScreen({
    element: 'body', // querySelector or HTMLElement
    interval: 1000   // milliseconds
});

// to capture shared parts of screen
// var image = document.querySelector('img');
connection.<a href="http://www.rtcmulticonnection.org/docs/onpartofscreen/">onpartofscreen</a> = function (e) {
    // image.src = e.screenshot;
};

// to pause part-of-screen sharing
connection.<a href="http://www.rtcmulticonnection.org/docs/peers/">peers</a>['target-userid'].pausePartOfScreenSharing = true;

// to stop part-of-screen sharing
connection.<a href="http://www.rtcmulticonnection.org/docs/peers/">peers</a>['target-userid'].stopPartOfScreenSharing = true;
</pre>
                </li>
                
                <li>
                    Now, <a href="http://www.rtcmulticonnection.org/docs/open/">open</a> method returns "sessionDescription" object. "open" method also accepts an object as well!
                    <ol>
            
                        <li>
                            <a href="http://www.rtcmulticonnection.org/docs/join/">join</a> method can be used to join that "sessionDescription" anytime without connecting to signaling channel!
                        </li>
            
                        <li>
                            <h2>For initiator:</h2>
                            <pre class="sh_javascript">
var initiator = new RTCMultiConnection();

// you can pass object instead of string!
var sessionDescription = initiator.<a href="http://www.rtcmulticonnection.org/docs/open/">open</a>({
    dontTransmit: true
});

websocket.send(sessionDescription);
</pre>
                        </li>
                
                        <li>
                        <h2>For participant:</h2>
                        <pre class="sh_javascript">
var participant = new RTCMultiConnection();

websocket.onmessage = function(event) {
    var sessionDescription = event.data.sessionDescription;
    participant.<a href="http://www.rtcmulticonnection.org/docs/join/">join</a>( sessionDescription );
};
</pre>


                    </ol>
                </li>
                
                <li>
                    Now, <a href="http://www.rtcmulticonnection.org/docs/removeStream/">removeStream</a> method quickly removes streams and auto renegotiates. You can also call <a href="http://www.rtcmulticonnection.org/docs/removeStream/">removeStream</a> over <a href="http://www.rtcmulticonnection.org/docs/peers/">peers</a> object:
                    <pre class="sh_javascript">
connection.<a href="http://www.rtcmulticonnection.org/docs/peers/">peers</a>['target-userid'].removeStream( 'stream-id' );
</pre>
                </li>
                
                <li>
                    Now, <a href="http://www.rtcmulticonnection.org/docs/onRequest/">onRequest</a> is fired only for <a href="http://www.rtcmulticonnection.org/docs/session-initiator/">session-initiator</a>.
                </li>
				
                <li>
                    "<a href="http://www.rtcmulticonnection.org/docs/shareMediaFile/">shareMediaFile</a>" and "<a href="http://www.rtcmulticonnection.org/docs/onMediaFile/">onMediaFile</a>" added. (i.e. pre-recorded media support added):
                    <pre class="sh_javascript">
// select WebM file to share as pre-recorded media!
document.querySelector('input[type=file]').onchange = function() {
    connection.<a href="http://www.rtcmulticonnection.org/docs/shareMediaFile/">shareMediaFile</a>( this.files[0] );
};

// receive WebM files
connection.<a href="http://www.RTCMultiConnection.org/docs/onMediaFile/">onMediaFile</a> = function(e) {
    // e.mediaElement (it is video-element)
    // e.userid
    // e.extra
    
    yourExistingVideoElement.src = e.mediaElement.src;
    
    // or
    document.body.appendChild(e.mediaElement);
};
</pre>
                </li>
                
                <li>
                    Mute/UnMute and "onstreamended" among multiple users, issues fixed.
                </li>
				
                <li>
                    Now, "<a href="http://www.RTCMultiConnection.org/docs/getDevices/">getDevices</a>" method skips duplicate devices and returns array of unique audio/video devices.
                </li>
				
                <li>
                    Now, "<a href="http://www.RTCMultiConnection.org/docs/onFileStart/">onFileStart</a>", "<a href="http://www.RTCMultiConnection.org/docs/onFileProgress/">onFileProgress</a>" and "<a href="http://www.RTCMultiConnection.org/docs/onFileEnd/">onFileEnd</a>" has remote user's ID, "sending" object and "<a href="http://www.RTCMultiConnection.org/docs/extra/">extra</a>" object:
                    <pre class="sh_javascript">
// file sending or receiving instance is started.
connection.<a href="http://www.RTCMultiConnection.org/docs/onFileStart/">onFileStart</a> = function(file) {
    // file.<a href="http://www.RTCMultiConnection.org/docs/userid/">userid</a>  ---- userid of the file sender
    // file.<a href="http://www.RTCMultiConnection.org/docs/extra/">extra</a>   ---- extra data from file sender
	
    // file.sending ---- true or false
};

// file sending or receiving instance is ended.
connection.<a href="http://www.RTCMultiConnection.org/docs/onFileEnd/">onFileEnd</a> = function(file) {
    // file.<a href="http://www.RTCMultiConnection.org/docs/userid/">userid</a>  ---- userid of the file sender
    // file.<a href="http://www.RTCMultiConnection.org/docs/extra/">extra</a>    ---- extra data from file sender
	
    // file.sending ---- true or false
};

// file sending or receiving instance is working.
connection.<a href="http://www.RTCMultiConnection.org/docs/onFileProgress/">onFileProgress</a> = function(chunk) {
    // chunk.<a href="http://www.RTCMultiConnection.org/docs/userid/">userid</a>  ---- userid of the file sender
    // chunk.<a href="http://www.RTCMultiConnection.org/docs/extra/">extra</a>    ---- extra data from file sender
	
    // chunk.sending ---- true or false
};
</pre>
                </li>
				
                <li>
                    "<a href="http://www.rtcmulticonnection.org/docs/onstream/">onstream</a>" has two new objects:
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/onstream/">onstream</a> = function(e) {
    // e.isVideo ---- if it is a  Video stream
    // e.isAudio ---- if it is an Audio stream
};
</pre>
                </li>
				
                <li>
                    File <a href="http://www.rtcmulticonnection.org/docs/chunkSize/">chunk-size</a> and <a href="http://www.rtcmulticonnection.org/docs/chunkInterval/">chunk-interval</a> are fixed for Firefox.
                </li>
                <li>
                    Now, when renegotiating media streams, v1.7 checks to verify if remote stream is delivered to end-user; if delivery fails, v1.7 auto tries renegotiation again.
                </li>
                <li>
                    Now, "isAcceptNewSession" is shifted to root-level. Using this feature, you can allow single user to join multiple rooms from the same <a href="http://www.RTCMultiConnection.org/docs/channel-id/">channel</a>:
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/onstream/">onstream</a> = function(event) {
    if(event.type == 'remote') {
        // set "isAcceptNewSession=true" so this user can get and join new session i.e. room
        // it means that "<a href="http://www.RTCMultiConnection.org/docs/onNewSession/">onNewSession</a>" will be fired for this user as soon as other room is available!
        connection.isAcceptNewSession = true;
    }
};
</pre>
                </li>
                <li>
                    Now, "<a href="http://www.RTCMultiConnection.org/docs/session/">session</a>" object is always passed over "<a href="http://www.RTCMultiConnection.org/docs/onstreamended/">onstreamended</a>" event; so, you can check which stream is stopped: screen or audio/video:
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/onstreamended/">onstreamended</a> = function(event) {
    if(event.<a href="http://www.RTCMultiConnection.org/docs/session/">session</a>.screen) { }                        // if screen stream is stopped.
    if(event.<a href="http://www.RTCMultiConnection.org/docs/session/">session</a>.audio && !event.<a href="http://www.RTCMultiConnection.org/docs/session/">session</a>.video) { } // if audio stream is stopped.
    if(event.<a href="http://www.RTCMultiConnection.org/docs/session/">session</a>.audio && event.<a href="http://www.RTCMultiConnection.org/docs/session/">session</a>.video) { }  // if audio+video stream is stopped.
    
    // event.type == 'local' || 'remote'
};
</pre>
                </li>
                <li>
                    v1.6 and earlier releases has a bug for renegotiated streams. When you try to stop renegotiated stream; it is removed only from 1st participant; not from all participants. This issue has been fixed in v1.7.
                </li>
                <li>
                    "<code>forceToStopRemoteStream</code>" added.
                    <pre class="sh_javascript">
var forceToStopRemoteStream = true;
connection.<a href="http://www.RTCMultiConnection.org/docs/streams/">streams</a>['remote-stream-id'].stop( forceToStopRemoteStream );
</pre>
                    This feature was disabled since v1.4 however now enabled by passing a single boolean over "<code>stop</code>" method.
                </li>
                
                <li>
                    Default session is always kept there; it was a bug in v1.6 and earlier releases. Each new renegotiated session was overriding old sessions.
                </li>
                
                <li>
                    Renegotiated sessions are always stored; and always renegotiated to newcomers.
                </li>
                
                <li>
                    Renegotiation of external streams along with external session added.
                </li>
                
                <li>
                    Remote stream stop & removal issues fixed. Now, "<code>onstreamended</code>" is always fired for all users according to the stream stopped.
                </li>
                
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/setDefaultEventsForMediaElement/"><code>setDefaultEventsForMediaElement</code></a>" added. i.e. mute/unmute are implemented by default! When you'll click mute button from native video control; v1.7 will auto invoke "mute" among all relevant peers.
                </li>
            </ol>
            
            </section>
            
            <section class="experiment">
		
            <h2 id="v1.6"><a href="http://www.rtcmulticonnection.org/changes-log/#v1.6">v1.6</a> / released in Jan 29, 2014</h2>
            
            <blockquote class="inline">
                <pre class="sh_html">
&lt;script src="//cdn.webrtc-experiment.com/RTCMultiConnection-v1.6.js"&gt;&lt;/script&gt;
</pre>
            </blockquote>
		
            <ol>
                <li>
                    Now v1.6 is capable to auto-redial if connection is dropped by any mean. (This feature is disabled because it was affecting renegotiation process).
                </li>
                
                <li>
                    Now you can join as audio-only, video-only or screen-only stream both on chrome and firefox:
                    <ol>
                        <li>
                            <pre class="sh_javascript">
// original session is "audio-only" stream
connection.<a href="http://www.RTCMultiConnection.org/docs/session/">session</a> = { audio: true };
connection.<a href="http://www.RTCMultiConnection.org/docs/onNewSession/">onNewSession</a> = function(session) {
    // join with both audio and video!
    session.join({audio: true, video: true});
};
</pre>
                        </li>
                        
                        <li>
                            <pre class="sh_javascript">
// original session is "audio+video" stream
connection.<a href="http://www.RTCMultiConnection.org/docs/session/">session</a> = { audio: true, video: true };
connection.<a href="http://www.RTCMultiConnection.org/docs/onNewSession/">onNewSession</a> = function(session) {
    // join with audio-only stream!
    session.join({audio: true});
};
</pre>
                        </li>
                    </ol>
                    
                </li>
                
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/fakeDataChannels/">fakeDataChannels</a>" added. Using "<a href="http://www.RTCMultiConnection.org/docs/fakeDataChannels/">fakeDataChannels</a>" object you can setup fake data connection while you're sharing audio/video/screen. You can do text-chat; share files; etc. without using WebRTC data channels.
                    <pre class="sh_javascript">
// audio+video and fake data connection
connection.<a href="http://www.RTCMultiConnection.org/docs/fakeDataChannels/">fakeDataChannels</a> = true;
connection.<a href="http://www.RTCMultiConnection.org/docs/session/">session</a> = { audio: true, video: true };

// only fake data connection; no audio; no video; no WebRTC data channel!
connection.<a href="http://www.RTCMultiConnection.org/docs/fakeDataChannels/">fakeDataChannels</a> = true;
connection.<a href="http://www.RTCMultiConnection.org/docs/session/">session</a> = { };
</pre>
                </li>
                
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/UA/">UA</a>" object added. It returns whether browser is chrome; firefox or mobile device:
                    <pre class="sh_javascript">
var isFirefox = connection.<a href="http://www.RTCMultiConnection.org/docs/UA/">UA</a>.Firefox;
var isChrome = connection.<a href="http://www.RTCMultiConnection.org/docs/UA/">UA</a>.Chrome;
var isMobileDevice = connection.<a href="http://www.RTCMultiConnection.org/docs/UA/">UA</a>.Mobile;
</pre>
                </li>
                
                <li>
                    Now you can <a href="http://www.rtcmulticonnection.org/docs/renegotiation/">renegotiate</a> data-connection in your existing audio/video/screen session!
                    <pre class="sh_javascript">
connection.<a href="http://www.rtcmulticonnection.org/docs/addStream">addStream</a>({
    data: true
});
</pre>
                </li>
                
                <li>
                    <a href="https://github.com/muaz-khan/WebRTC-Experiment/issues/152">Pull #152</a> merged for "<a href="http://www.RTCMultiConnection.org/docs/token/">token</a>" method:
                    <pre class="sh_javascript">
var randomString = connection.<a href="http://www.RTCMultiConnection.org/docs/token/">token</a>();
connection.<a href="http://www.RTCMultiConnection.org/docs/userid/">userid</a> = connection.<a href="http://www.RTCMultiConnection.org/docs/token/">token</a>();
</pre>
                </li>
                
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/autoTranslateText/">autoTranslateText</a>" method added:
                    <pre class="sh_javascript">
// all incoming text messages will be converted in this language
// by default, it is "en-US"
connection.<a href="http://www.RTCMultiConnection.org/docs/language/">language</a> = 'ja'; // prefer Japanese

// it is "false" by default.
connection.<a href="http://www.RTCMultiConnection.org/docs/autoTranslateText/">autoTranslateText</a> = true;

// you can use "e.data" and "e.original"
connection.<a href="http://www.RTCMultiConnection.org/docs/onmessage/">onmessage</a> = function(e) {
   // e.data     ---- translated text
   // e.original ---- original text
};

connection.<a href="http://www.RTCMultiConnection.org/docs/Translator/">Translator</a>.TranslateText(textToConvert, function(convertedText) {
     console.log(convertedText);
});
</pre>
                </li>
                
                <li>
                    "session.join" method added. Remember, it is "<strong>session</strong>.join"; it isn't "<strong>connection</strong>.join"!
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/onNewSession/">onNewSession</a> = function(session) {
    session.join();                           // join session as it is!
    session.join({audio: true});              // join session while allowing only audio
    session.join({video: true});              // join session while allowing only video
    session.join({screen: true});             // join session while allowing only screen
    session.join({audio: true, video: true}); // join session while allowing both audio and video
};
</pre>
                </li>
                
                <li>
                    <a href="https://github.com/muaz-khan/WebRTC-Experiment/issues/152">Bug #152</a> fixed.
                </li>
                
                <li>
                    Now, <a href="https://github.com/muaz-khan/WebRTC-Experiment/tree/master/RecordRTC/MRecordRTC">MRecordRTC</a> is used for <a href="http://www.RTCMultiConnection.org/docs/startRecording/">audio/video recording</a>!
                </li>
                
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/saveToDisk/">saveToDisk</a>" method added. You can invoke save-as dialog like this:
					
                    <pre class="sh_javascript">
// "fileName" is optional
connection.<a href="http://www.RTCMultiConnection.org/docs/saveToDisk/">saveToDisk</a>(fileURL, fileName);

// you can save recorded blob to disk like this:
connection.streams['stream-id'].<a href="http://www.RTCMultiConnection.org/docs/stopRecording/">stopRecording</a>(function (audioBlob, videoBlob) {
    connection.<a href="http://www.RTCMultiConnection.org/docs/saveToDisk/">saveToDisk</a>(audioBlob);
    connection.<a href="http://www.RTCMultiConnection.org/docs/saveToDisk/">saveToDisk</a>(videoBlob);
}, {audio:true, video:true} );
</pre>

                </li>
                
                <li>
                    If you're recording both audio and video; then "<a href="http://www.RTCMultiConnection.org/docs/stopRecording/">stopRecording</a>" will return both blobs in the single callback; where 1st parameter value will be audio-blob; and 2nd parameter value will be video-blob:
					
                    <pre class="sh_javascript">
// stop both audio/video streams
connection.streams['stream-id'].<a href="http://www.RTCMultiConnection.org/docs/stopRecording/">stopRecording</a>(function (audioBlob, videoBlob) {
    // POST both audio/video "Blobs" to PHP/other server using single FormData/XHR2
}, {audio:true, video:true} );
</pre>

                </li>
                
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/onhold/">onhold</a>" and "<a href="http://www.RTCMultiConnection.org/docs/onunhold/">onunhold</a>" events added:
					
                    <pre class="sh_javascript">
// to hold call; same like skype!
connection.<a href="http://www.RTCMultiConnection.org/docs/peers/">peers</a>['user-id'].hold();
connection.<a href="http://www.RTCMultiConnection.org/docs/onhold/">onhold</a> = function(e) {
	// e.mediaElement || e.stream || e.userid || e.streamid
};

// to unhold call; same like skype!
connection.<a href="http://www.RTCMultiConnection.org/docs/peers/">peers</a>['user-id'].unhold();
connection.<a href="http://www.RTCMultiConnection.org/docs/onunhold/">onunhold</a> = function(e) {
	// e.mediaElement || e.stream || e.userid || e.streamid
};
</pre>

                </li>
                
                <li>
                    Many method has been added in "<a href="http://www.RTCMultiConnection.org/docs/peers/">peers</a>" object.
				
                    <pre class="sh_javascript">
// renegotiate while adding external media streams
connection.<a href="http://www.RTCMultiConnection.org/docs/peers/">peers</a>['user-id'].renegotiate(Custom_MediaStream);

// renegotiate while no media stream is added
connection.<a href="http://www.RTCMultiConnection.org/docs/peers/">peers</a>['user-id'].renegotiate();

// change bandwidth at runtime
connection.<a href="http://www.RTCMultiConnection.org/docs/peers/">peers</a>['user-id'].changeBandwidth({
    audio: 20,
    video: 30,
    data: 50
});

// send private message to target user; privacy is guaranteed!
connection.<a href="http://www.RTCMultiConnection.org/docs/peers/">peers</a>['user-id'].sendCustomMessage('private-message');
connection.<a href="http://www.RTCMultiConnection.org/docs/peers/">peers</a>['user-id'].onCustomMessage = function(privateMessage) {
    console.log('private custom message', privateMessage);
};

// to drop call; same like skype!
connection.<a href="http://www.RTCMultiConnection.org/docs/peers/">peers</a>['user-id'].drop();

// to hold call; same like skype!
connection.<a href="http://www.RTCMultiConnection.org/docs/peers/">peers</a>['user-id'].hold();

// to unhold call; same like skype!
connection.<a href="http://www.RTCMultiConnection.org/docs/peers/">peers</a>['user-id'].unhold();
</pre>

                    <ol>
                        <li>
                            "changeBandwidth" method is useful to modify bandwidth usage at runtime!
                        </li>
					
                        <li>
                            "drop" method is useful to drop call between two users same like skype!
                        </li>
					
                        <li>
                            "sendCustomMessage" and "onCustomMessage" are useful to exchange private data between two users where your preferred signaling solution is used to send data i.e. it works all the time! Remember, there is a public version of "<a href="http://www.RTCMultiConnection.org/docs/sendCustomMessage/">sendCustomMessage</a>" as well!
                        </li>
					
                        <li>
                            "hold" and "unhold" works same like skype!
                        </li>
                    </ol>
                </li>
                
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/renegotiate/">renegotiate</a>" method added.
                    <pre class="sh_javascript">
// renegotiate with/without media streams!
connection.<a href="http://www.RTCMultiConnection.org/docs/renegotiate/">renegotiate</a>(Custom_MediaStream);
</pre>
                    <p>
                        "<a href="http://www.RTCMultiConnection.org/docs/renegotiate/">renegotiate</a>" method works same like "<a href="http://www.RTCMultiConnection.org/docs/addStream/">addStream</a>" however it gives you a little bit more control over renegotiation process!
                    </p>
				
                    <p>
                        If connection is suddently dropped; or connection has not been established for 5 seconds; then you can use "<a href="http://www.RTCMultiConnection.org/docs/renegotiate/">renegotiate</a>" method to retry/redial.
                    </p>
				
                    <p>
                        In multi-user connectivity scenarios; it is suggested to try "<a href="http://www.RTCMultiConnection.org/docs/peers/">peers</a>" object to renegotiate/retry/redial connections. See next section for more details.
                    </p>
                </li>
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/refresh/">refresh</a>" method added.
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/refresh/">refresh</a>();
</pre>
                    <p>
                        Using "<a href="http://www.RTCMultiConnection.org/docs/refresh/">refresh</a>" method; you can refresh/reload the RTCMultiConnection object!
                    </p>
                </li>
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/remove/">remove</a>" method added.
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/remove/">remove</a>('user-id');
</pre>
                    <p>
                        Using "<a href="http://www.RTCMultiConnection.org/docs/remove/">remove</a>" method; you can clear all sockets, peers and streams coming from that user; so that he can reconnect to the same <a href="http://www.RTCMultiConnection.org/docs/sessionid/">session</a>!
                    </p>
                </li>
                <li>File sharing is improved! Chrome/Firefox interoperability support added.</li>
                <li>"<a href="http://www.RTCMultiConnection.org/docs/preferSCTP/">preferSCTP</a>" is now enabled by default.</li>
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/chunkSize/">chunkSize</a>" added. You can set 64k chunk-size for chrome-to-chrome SCTP-data streaming!
                    <pre class="sh_javascript">
// for chrome-to-chrome data streaming only!
connection.<a href="http://www.RTCMultiConnection.org/docs/chunkSize/">chunkSize</a> = 64 * 1000;

// default value is 15k because Firefox's receiving limit is 16k!
connection.<a href="http://www.RTCMultiConnection.org/docs/chunkSize/">chunkSize</a> = 15 * 1000;
</pre>
                </li>
                
                <li>
                    All possible "complex" <a href="http://www.RTCMultiConnection.org/docs/renegotiation/">renegotiation</a> scenarios are supported!
                    <ol>
                        <li>
                            You can select any participant to broadcast his screen or media stream in oneway direction over all connected users!
                        </li>
					
                        <li>
                            There can be 5 broadcasters; and many viewers/listeners!
                        </li>
					
                        <li>
                            Each and every skype-like feature is possible using v1.6! You can add/remove streams many times using existing peer connections!
                        </li>
                    </ol>
                </li>
            </ol>
            
            </section>
            
            <section class="experiment">
		
            <h2 id="v1.5"><a href="http://www.rtcmulticonnection.org/changes-log/#v1.5">v1.5</a> / released in Dec 31, 2013</h2>
            
            <blockquote class="inline">
                <pre class="sh_html">
&lt;script src="//cdn.webrtc-experiment.com/RTCMultiConnection-v1.5.js"&gt;&lt;/script&gt;
</pre>
            </blockquote>
            
            <ol>
                <li>
                    You can get list of devices using "<a href="http://www.RTCMultiConnection.org/docs/getDevices/">getDevices</a>" method and prefer any single or two audio/video devices using "<a href="http://www.RTCMultiConnection.org/docs/selectDevices/">selectDevices</a>" method.
                    <pre class="sh_javascript">
// get list of devices
connection.getDevices(function(devices){
    for (var device in devices) {
        device = devices[device];
        
        // device.kind == 'audio' || 'video'
        console.log(device.id, device.label);
    }
});

// select any audio and/or video device
connection.selectDevices(firstDeviceID, secondDeviceID);
</pre>
                </li>
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/onspeaking/">onspeaking</a>" and "<a href="http://www.RTCMultiConnection.org/docs/onsilence/">onsilence</a>" added.
                    <pre class="sh_javascript">
connection.onspeaking = function (e) {
    // e.streamid, e.userid, e.stream, etc.
    e.mediaElement.style.border = '1px solid red';
};

connection.onsilence = function (e) {
    // e.streamid, e.userid, e.stream, etc.
    e.mediaElement.style.border = '';
};
</pre>
                </li>
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/stop/">connection.streams.stop</a>" added to stop all local/remote streams.
                    <pre class="sh_javascript">
// stop all local media streams
connection.streams.stop('local');

// stop all remote media streams
connection.streams.stop('remote');

// stop all media streams
connection.streams.stop();
</pre>
                </li>
                <li><a href="http://www.RTCMultiConnection.org/docs/mute/">mute</a>/<a href="http://www.RTCMultiConnection.org/docs/unmute/">unmute</a> and "<a href="http://www.RTCMultiConnection.org/docs/stop/">stop</a>" fixed both for chrome and firefox.</li>
                <li>
                    <a href="http://www.RTCMultiConnection.org/docs/onmute/">onmute</a>/<a href="http://www.RTCMultiConnection.org/docs/onunmute/">onunmute</a> auto displays "poster" if not overridden! (both on chrome and firefox)
                    <pre class="sh_javascript">
connection.onmute = function(e) {
    e.mediaElement.setAttribute('poster', 
                                'www.webrtc-experiment.com/images/muted.png');
};

connection.onunmute = function (e) {
    e.mediaElement.removeAttribute('poster');
};
</pre>
                </li>
                <li>If screen-sharing is stopped using blue button, "<strong>onstreamended</strong>" will be auto fired for both users!</li>
                <li>"<a href="http://www.RTCMultiConnection.org/docs/onstream/">onstream</a>" auto appends video to "<a href="http://www.RTCMultiConnection.org/docs/body/">document.body</a>" element; if not overridden!</li>
                <li>Default file progress-bar implemented.</li>
                <li>
                    <p>You can manage videos and "progress-bar" container element by setting "<a href="http://www.RTCMultiConnection.org/docs/body/">connection.body</a>".</p>
                    <pre class="sh_javascript">
&lt;div class="container"&gt;&lt;/div&gt;
connection.body = document.querySelector('.container');
</pre>
                </li>
			
                <li>
                    Throws a clear error if users try to interop RTP-datachannels with <a href="http://www.RTCMultiConnection.org/docs/preferSCTP/">SCTP</a>.
                </li>
            
                <li>
                    <a href="http://www.RTCMultiConnection.org/docs/onunmute/">onmute</a>/<a href="http://www.RTCMultiConnection.org/docs/onunmute/">onunmute</a> are fixed for both local and remote media streams. Both streams will be <a href="https://github.com/muaz-khan/WebRTC-Experiment/issues/135#issuecomment-31289682">auto-synced</a>!
                </li>
            
                <li>
                    Now, only <a href="http://www.RTCMultiConnection.org/docs/session-initiator/">session-initiator</a> can <a href="http://www.RTCMultiConnection.org/docs/eject/">eject</a> a user.
                </li>
            
                <li>
                    <a href="http://www.RTCMultiConnection.org/docs/takeSnapshot/">takeSnapshot</a>/<a href="http://www.RTCMultiConnection.org/docs/snapshots/">snapshots</a> added:
                    <pre class="sh_javascript">
// iterate over all snapshots/
for(var snapshot in connection.<a href="http://www.RTCMultiConnection.org/docs/snapshots/">snapshots</a>) {
    snapshot = connection.snapshots[snapshot];
}

// or, to access individual snapshot later
image.src = connection.<a href="http://www.RTCMultiConnection.org/docs/snapshots/">snapshots</a>['userid'];

// to take a snapshot
connection.<a href="http://www.RTCMultiConnection.org/docs/takeSnapshot/">takeSnapshot</a>('userid', function(snapshot) {
    image.src = snapshot;
});
</pre>
                </li>
            
                <li>
                    <a href="http://www.RTCMultiConnection.org/docs/session-initiator/">Session initiator</a> can now <a href="http://www.RTCMultiConnection.org/docs/stop/">stop</a> remote media streams. It works same like <a href="http://www.RTCMultiConnection.org/docs/eject/">eject</a> method:
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/streams/">streams</a>['remote-stream-id'].stop();
</pre>
                </li>
            
                <li>
                    <a href="http://www.RTCMultiConnection.org/docs/reject/">reject</a> method added. Now, you can reject any request in <a href="http://www.RTCMultiConnection.org/docs/onRequest/">onRequest</a> event.:
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/onRequest/">onRequest</a> = function (request) {
    connection.<a href="http://www.RTCMultiConnection.org/docs/reject/">reject</a>(request);
};

// "onstats" event can be used to know whether request is rejected or accepted
connection.<a href="http://www.RTCMultiConnection.org/docs/onstats/">onstats</a> = function (stats, callee) {
    // callee rejected the request
    if (stats == 'rejected') {}

    // callee accepted caller's request
    if (stats == 'accepted') {}
    
    // callee.userid || callee.extra
};
</pre>
                </li>
            
                <li>
                    <a href="http://www.RTCMultiConnection.org/docs/getStats/">getStats</a> and <a href="http://www.RTCMultiConnection.org/docs/stats/">stats</a> added.
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/getStats/">getStats</a>(function(stat) {
    // stat.numberOfConnectedUsers
});

for(var stat in connection.<a href="http://www.RTCMultiConnection.org/docs/stats/">stats</a>) {
    console.log(stat, connection.<a href="http://www.RTCMultiConnection.org/docs/stats/">stats</a>[stat]);
}

// you can directly access "numberOfConnectedUsers" later like this:
console.log(connection.<a href="http://www.RTCMultiConnection.org/docs/stats/">stats</a>.numberOfConnectedUsers);
</pre>
                </li>
            
                <li>
                    <a href="http://www.RTCMultiConnection.org/docs/caniuse/">caniuse</a> added.
                    <pre class="sh_javascript">
console.log( connection.<a href="http://www.RTCMultiConnection.org/docs/caniuse/">caniuse</a>.RTCPeerConnection );
console.log( connection.<a href="http://www.RTCMultiConnection.org/docs/caniuse/">caniuse</a>.getUserMedia );
console.log( connection.<a href="http://www.RTCMultiConnection.org/docs/caniuse/">caniuse</a>.AudioContext );
console.log( connection.<a href="http://www.RTCMultiConnection.org/docs/caniuse/">caniuse</a>.ScreenSharing );
console.log( connection.<a href="http://www.RTCMultiConnection.org/docs/caniuse/">caniuse</a>.RtpDataChannels );
console.log( connection.<a href="http://www.RTCMultiConnection.org/docs/caniuse/">caniuse</a>.SctpDataChannels );


connection.<a href="http://www.RTCMultiConnection.org/docs/caniuse/">caniuse</a>.checkIfScreenSharingFlagEnabled(function (isFlagEnabled, warning) {
    if (isFlagEnabled) {
        console.error('Multi-capturing of screen is not allowed. Capturing process is denied. Try chrome >= M31.');
    }

    if (warning) console.error(warning);

    else if (!isFlagEnabled) {
        console.error('It seems that "Enable screen capture support in getUserMedia" flag is not enabled.');
    }
});
</pre>
                </li>
            
            
					
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/drop/">drop</a>" added. Using <a href="http://www.RTCMultiConnection.org/docs/drop/">drop</a> method; you can drop the call, same like skype! This method will detach all "local" media streams from both sides.
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/drop/">drop</a>();
</pre>
                </li>
					
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/ondrop/">ondrop</a>" event added. It is fired if other user drops the call.
                    <pre class="sh_javascript">
// "ondrop" is fired; if media-connection is droppped by other user
connection.<a href="http://www.RTCMultiConnection.org/docs/ondrop/">ondrop</a> = function() { };
</pre>
                </li>
                    
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/sendCustomMessage/">sendCustomMessage</a>" added. Using <a href="http://www.RTCMultiConnection.org/docs/sendCustomMessage/">sendCustomMessage</a> method; you can share public messages over the default socket. E.g.
				
                    <ol>
                        <li>
                            State of the <a href="http://www.RTCMultiConnection.org/docs/session-participant/">session-participant</a> or <a href="http://www.RTCMultiConnection.org/docs/session-initiator/">session-initiator</a>; whether he is going to leave; or going to share a media stream.
                        </li>
					
                        <li>
                            Ask a <a href="http://www.RTCMultiConnection.org/docs/session-participant/">session-participant</a> to broadcast screen or video in one-way <a href="http://www.RTCMultiConnection.org/docs/direction/">direction</a>.
                        </li>
					
                        <li>
                            Ask <a href="http://www.RTCMultiConnection.org/docs/session-participant/">session-participants</a> to attach audio stream; even if it is oneway stream coming from <a href="http://www.RTCMultiConnection.org/docs/session-initiator/">session-initiator</a>.
                        </li>
					
                        <li>
                            There are unlimited scenarios; that can be accomplished using <a href="http://www.RTCMultiConnection.org/docs/sendCustomMessage/">sendCustomMessage</a> method; just imagine and go ahead and use it!
                        </li>
                    </ol>
                </li>
					
                <li>
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/sendCustomMessage/">sendCustomMessage</a>(any_kind_of_data |or| string_message);
</pre>
                </li>
					
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/onCustomMessage/">onCustomMessage</a>" event added. Custom messages can be received using <a href="http://www.RTCMultiConnection.org/docs/onCustomMessage/">onCustomMessage</a> event.
                    <pre class="sh_javascript">
connection.<a href="http://www.RTCMultiConnection.org/docs/onCustomMessage/">onCustomMessage</a> = function(message) { };
</pre>
                </li>
                    
                <li>
                    Echo issue; i.e. self-sound playback fixed.
                </li>
            
                <li>
                    "<a href="http://www.RTCMultiConnection.org/docs/stopRecording/">stopRecording</a>" now returns both audio/video blobs in the single "callback"!
                
                    <pre class="sh_javascript">
// stop single audio stream
connection.streams['stream-id'].<a href="http://www.RTCMultiConnection.org/docs/stopRecording/">stopRecording</a>(function (blob) {
    // POST "Blob" to PHP/other server using FormData/XHR2
}, {audio:true});

// stop single video stream
connection.streams['stream-id'].<a href="http://www.RTCMultiConnection.org/docs/stopRecording/">stopRecording</a>(function (blob) {
    // POST "Blob" to PHP/other server using FormData/XHR2
}, {video:true});

// stop both audio/video streams
connection.streams['stream-id'].<a href="http://www.RTCMultiConnection.org/docs/stopRecording/">stopRecording</a>(function (audioBlob, videoBlob) {
    // POST both audio/video "Blobs" to PHP/other server using single FormData/XHR2
}, {audio:true, video:true} );
</pre>
                </li>
            </ol>
            
            </section>
            
            <section class="experiment">
		
            <h2 id="v1.4"><a href="http://www.rtcmulticonnection.org/changes-log/#v1.4">v1.4</a> / released in July 06, 2013</h2>
		
            <blockquote class="inline">
                <pre class="sh_html">
&lt;script src="//cdn.webrtc-experiment.com/RTCMultiConnection-v1.4.js"&gt;&lt;/script&gt;
</pre>
            </blockquote>
        
            <ol>
                <li>Multiple concurrent files transmission / see <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/a0f9b72654b3ba7c5232968d9850e35fb770bbbb#RTCMultiConnection" target="_blank">commit</a></li>
                <li>Advance renegotiation</li>
                <li>Admin/Guest features; useful in realtime chatting rooms where direct invitation is mandatory / see <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/572ac336357b8530d779529e109197ea7b8f6f8e#RTCMultiConnection" target="_blank">commit</a></li>
                <li>Multi-streams attachment i.e. audio+video+data+screen / see <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/075eaa978399a2309b664164e875187ec7b6444a#RTCMultiConnection" target="_blank">commit</a></li>
                <li>Mute/UnMute/Stop of individual, all at once; all remote or all local streams</li>
                <li>onstreamended added; a better method comparing "onleave"</li>
                <li>maxParticipantsAllowed added</li>
                <li>media/sdp constraints / see <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/8d76c0cb5be4d8df17c6603220c091b8ea2ff0f6#RTCMultiConnection" target="_blank">commit</a></li>
                <li>Session re-initiation / see <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/a0f9b72654b3ba7c5232968d9850e35fb770bbbb#RTCMultiConnection" target="_blank">commit</a></li>
                <li>removeStream added to allow removal of existing media streams</li>
                <li>disableDtlsSrtp added to fix renegotiation process which fails on chrome when DTLS/SRTP enabled</li>
                <li>autoSaveToDisk added to allow customization of file-sharing</li>
                <li>file-sharing extended and fixed; no crash for large files anymore!</li>
                <li>renegotiation for chrome M29 and upper</li>
                <li>sctp/reliable data channels support for chrome (unreliable is still default)</li>
                <li>enable/disable ice candidates (host/relfexive/relay)</li>
                <li>enable/disable bandwidth sdp parameters (by default, enabled)</li>
                <li>noise/echo stepped down; a simple/lazy workaround</li>
                <li>audio/video recording added / using <a href="https://github.com/muaz-khan/WebRTC-Experiment/tree/master/RecordRTC" target="_blank">RecordRTC</a></li>
                <li>directions simplified</li>
                <li>SCTP data channels are preferred / preferSCTP</li>
                <li>onmute/onunmute added. <a href="https://www.webrtc-experiment.com/RTCMultiConnection-v1.4-Demos/mute-unmute.html" target="_blank">Demo</a></li>
                <li>File queue support added. Previously shared files will be auto transmitted to each new peer.</li>
            </ol>
            
            </section>
            
            <section class="experiment">
		
            <h2 id="v1.3"><a href="http://www.rtcmulticonnection.org/changes-log/#v1.3">v1.3</a> / released in May 19, 2013</h2>
		
            <blockquote class="inline">
                <pre class="sh_html">
&lt;script src="//cdn.webrtc-experiment.com/RTCMultiConnection-v1.3.js"&gt;&lt;/script&gt;
</pre>
            </blockquote>
        
            <ol>
                <li>Syntax changed; a few breaking changes comparing v1.2 / <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/ac368557ce857dad1fbcf70aa58813d50cec6047#RTCMultiConnection" target="_blank">see commit</a></li>
                <li>Simple renegotiation</li>
                <li>Mute/UnMute of individual streams</li>
                <li>Auto-session establishment feature removed</li>
                <li>Application specific bandwidth (b=AS) / see <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/6df6a5507268c84b91fe8445f0b9ef1f5781b687#RTCMultiConnection" target="_blank">commit</a> and <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/b38a22834593cfc02893d320500dfb609f519580#RTCMultiConnection" target="_blank">commit</a></li>
                <li>Direct Messages</li>
                <li>New TURN format added / see <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/c0688f9eabfee4113150f3d362f2b3a2aa5c2895#RTCMultiConnection" target="_blank">commit</a> / <a href="http://tools.ietf.org/html/draft-uberti-rtcweb-turn-rest-00" target="_blank">IETF Draft</a></li>
                <li>Compatible to <a href="https://github.com/muaz-khan/WebRTC-Experiment/tree/master/socketio-over-nodejs" target="_blank">socket.io over node.js</a> / see <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/b2e7789bcb79a4248090081750e26c984a76d0b0#RTCMultiConnection" target="_blank">commit</a></li>
            </ol>
            
            </section>
            
            <section class="experiment">
		
            <h2 id="v1.2"><a href="http://www.rtcmulticonnection.org/changes-log/#v1.2">v1.2</a> / released in April 20, 2013</h2>
		
            <blockquote class="inline">
                <pre class="sh_html">
&lt;script src="//cdn.webrtc-experiment.com/RTCMultiConnection-v1.2.js"&gt;&lt;/script&gt;
</pre>
            </blockquote>
            
            <ol>
                <li>Multi-session establishment</li>
                <li>Auto-session establishment</li>
                <li>Manual-session establishment</li>
                <li>A little bit clear session/direction values e.g. <pre class="sh_javascript">connection.session='audio + video and data'</pre></li>
                <li>Users ejection, rejection and presence detection / <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/305dd27af73c9219183f78120e8ebbb8443efb1e#RTCMultiConnection" target="_blank">see commit</a></li>
                <li>Keep session active all the time; event if initiator leaves / <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/bd8ae0f5529e7a3900ef5ccac61f1364390be6b3#RTCMultiConnection" target="_blank">see commit</a></li>
                <li>Custom data i.e. extra data transmission</li>
                <li>Audio-only streaming fixed / <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/a4a6c3589e341617767213703683f1dba6c7548e#RTCMultiConnection" target="_blank">see commit</a></li>
                <li>Custom Handlers for server i.e. <strong>transmitRoomOnce</strong></li>
            </ol>
            
            </section>
            
            <section class="experiment">
		
            <h2 id="v1.1"><a href="http://www.rtcmulticonnection.org/changes-log/#v1.1">v1.1</a> / released in March 25, 2013</h2>
		
            <blockquote class="inline">
                <pre class="sh_html">
&lt;script src="//cdn.webrtc-experiment.com/RTCMultiConnection-v1.1.js"&gt;&lt;/script&gt;
</pre>
            </blockquote>
        
            <ol>
                <li>Multiple sessions & directions / <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/017431280099e892744a6300ea866e7324f5e4c2#RTCMultiConnection" target="_blank">see commit</a></li>
                <li>File, data and text sharing (of any size & length)</li>
                <li>Chrome/Firefox interoperability</li>
                <li>Firefox's <a href="https://github.com/muaz-khan/WebRTC-Experiment/wiki/WebRTC-DataChannel-and-Firefox#points" target="_blank">new DataChannel syntax</a> implemented / <a href="https://github.com/muaz-khan/WebRTC-Experiment/commit/7bad719345814c7f832fad59abf31642e096b276#RTCMultiConnection" target="_blank">see commit</a></li>
            </ol>
            
            </section>

            <br />
            <br />
            <section style="border: 1px solid rgb(189, 189, 189); border-radius: .2em; margin: 1em 3em;">
                <h2 id="feedback" style="border-bottom: 1px solid rgb(189, 189, 189); padding: .2em .4em;">Want to ask a Question?</h2>
                <div>
                    <textarea id="message" style="border: 1px solid rgb(189, 189, 189); height: 8em; margin: .2em; outline: none; resize: vertical; width: 98%;" placeholder="Feel free to ask any question regarding RTCMultiConnection.js!"></textarea>
                </div>
                <button id="send-message" style="font-size: 1em;">Ask a Question</button><small style="margin-left: 1em;">You can include your email for private conversation!</small>
            </section>
            
            <section class="experiment own-widgets latest-commits">
                <h2 class="header" id="updates" style="color: red; padding-bottom: .1em;"><a href="https://github.com/muaz-khan/WebRTC-Experiment/commits/master" target="_blank">Latest Updates</a></h2>
                <div id="github-commits"></div>
            </section>
        </article>
	
        <a href="https://github.com/muaz-khan/RTCMultiConnection" class="fork-left"></a>
	
        <footer>
            <a href="https://www.webrtc-experiment.com/" target="_blank">WebRTC Experiments!</a> and 
            <a href="http://www.RTCMultiConnection.org/docs/" target="_blank">RTCMultiConnection.js</a> ©
            <a href="mailto:muazkh@gmail.com" target="_blank">Muaz Khan</a>:
            <a href="https://twitter.com/WebRTCWeb" target="_blank">@WebRTCWeb</a>
        </footer>
        <script src="https://cdn.webrtc-experiment.com/commits.js"> </script>
    </body>
</html>
